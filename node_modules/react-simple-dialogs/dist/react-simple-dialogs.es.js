'use client';
import * as q from "react";
import We, { createContext as Gt, useLayoutEffect as po, useEffect as le, useContext as X, useRef as ht, useInsertionEffect as Cs, useCallback as yn, useMemo as $t, forwardRef as mo, createElement as go, useId as kn, useState as ce, cloneElement as yo, Children as vo, isValidElement as xo } from "react";
import bo from "react-dom";
var vn = { exports: {} }, Zt = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var mr;
function Po() {
  if (mr)
    return Zt;
  mr = 1;
  var t = We, e = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, s = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, o = { key: !0, ref: !0, __self: !0, __source: !0 };
  function i(a, l, c) {
    var u, f = {}, h = null, p = null;
    c !== void 0 && (h = "" + c), l.key !== void 0 && (h = "" + l.key), l.ref !== void 0 && (p = l.ref);
    for (u in l)
      r.call(l, u) && !o.hasOwnProperty(u) && (f[u] = l[u]);
    if (a && a.defaultProps)
      for (u in l = a.defaultProps, l)
        f[u] === void 0 && (f[u] = l[u]);
    return { $$typeof: e, type: a, key: h, ref: p, props: f, _owner: s.current };
  }
  return Zt.Fragment = n, Zt.jsx = i, Zt.jsxs = i, Zt;
}
var Jt = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var gr;
function To() {
  return gr || (gr = 1, process.env.NODE_ENV !== "production" && function() {
    var t = We, e = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), s = Symbol.for("react.strict_mode"), o = Symbol.for("react.profiler"), i = Symbol.for("react.provider"), a = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), c = Symbol.for("react.suspense"), u = Symbol.for("react.suspense_list"), f = Symbol.for("react.memo"), h = Symbol.for("react.lazy"), p = Symbol.for("react.offscreen"), m = Symbol.iterator, v = "@@iterator";
    function T(d) {
      if (d === null || typeof d != "object")
        return null;
      var g = m && d[m] || d[v];
      return typeof g == "function" ? g : null;
    }
    var P = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function y(d) {
      {
        for (var g = arguments.length, b = new Array(g > 1 ? g - 1 : 0), S = 1; S < g; S++)
          b[S - 1] = arguments[S];
        x("error", d, b);
      }
    }
    function x(d, g, b) {
      {
        var S = P.ReactDebugCurrentFrame, M = S.getStackAddendum();
        M !== "" && (g += "%s", b = b.concat([M]));
        var j = b.map(function(D) {
          return String(D);
        });
        j.unshift("Warning: " + g), Function.prototype.apply.call(console[d], console, j);
      }
    }
    var w = !1, R = !1, N = !1, k = !1, V = !1, L;
    L = Symbol.for("react.module.reference");
    function et(d) {
      return !!(typeof d == "string" || typeof d == "function" || d === r || d === o || V || d === s || d === c || d === u || k || d === p || w || R || N || typeof d == "object" && d !== null && (d.$$typeof === h || d.$$typeof === f || d.$$typeof === i || d.$$typeof === a || d.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      d.$$typeof === L || d.getModuleId !== void 0));
    }
    function nt(d, g, b) {
      var S = d.displayName;
      if (S)
        return S;
      var M = g.displayName || g.name || "";
      return M !== "" ? b + "(" + M + ")" : b;
    }
    function rt(d) {
      return d.displayName || "Context";
    }
    function G(d) {
      if (d == null)
        return null;
      if (typeof d.tag == "number" && y("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof d == "function")
        return d.displayName || d.name || null;
      if (typeof d == "string")
        return d;
      switch (d) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case o:
          return "Profiler";
        case s:
          return "StrictMode";
        case c:
          return "Suspense";
        case u:
          return "SuspenseList";
      }
      if (typeof d == "object")
        switch (d.$$typeof) {
          case a:
            var g = d;
            return rt(g) + ".Consumer";
          case i:
            var b = d;
            return rt(b._context) + ".Provider";
          case l:
            return nt(d, d.render, "ForwardRef");
          case f:
            var S = d.displayName || null;
            return S !== null ? S : G(d.type) || "Memo";
          case h: {
            var M = d, j = M._payload, D = M._init;
            try {
              return G(D(j));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var O = Object.assign, B = 0, st, lt, xe, Yt, Ht, F, vt;
    function Kt() {
    }
    Kt.__reactDisabledLog = !0;
    function be() {
      {
        if (B === 0) {
          st = console.log, lt = console.info, xe = console.warn, Yt = console.error, Ht = console.group, F = console.groupCollapsed, vt = console.groupEnd;
          var d = {
            configurable: !0,
            enumerable: !0,
            value: Kt,
            writable: !0
          };
          Object.defineProperties(console, {
            info: d,
            log: d,
            warn: d,
            error: d,
            group: d,
            groupCollapsed: d,
            groupEnd: d
          });
        }
        B++;
      }
    }
    function Pe() {
      {
        if (B--, B === 0) {
          var d = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: O({}, d, {
              value: st
            }),
            info: O({}, d, {
              value: lt
            }),
            warn: O({}, d, {
              value: xe
            }),
            error: O({}, d, {
              value: Yt
            }),
            group: O({}, d, {
              value: Ht
            }),
            groupCollapsed: O({}, d, {
              value: F
            }),
            groupEnd: O({}, d, {
              value: vt
            })
          });
        }
        B < 0 && y("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var ct = P.ReactCurrentDispatcher, Lt;
    function jt(d, g, b) {
      {
        if (Lt === void 0)
          try {
            throw Error();
          } catch (M) {
            var S = M.stack.trim().match(/\n( *(at )?)/);
            Lt = S && S[1] || "";
          }
        return `
` + Lt + d;
      }
    }
    var Vt = !1, ut;
    {
      var ft = typeof WeakMap == "function" ? WeakMap : Map;
      ut = new ft();
    }
    function qt(d, g) {
      if (!d || Vt)
        return "";
      {
        var b = ut.get(d);
        if (b !== void 0)
          return b;
      }
      var S;
      Vt = !0;
      var M = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var j;
      j = ct.current, ct.current = null, be();
      try {
        if (g) {
          var D = function() {
            throw Error();
          };
          if (Object.defineProperty(D.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(D, []);
            } catch (dt) {
              S = dt;
            }
            Reflect.construct(d, [], D);
          } else {
            try {
              D.call();
            } catch (dt) {
              S = dt;
            }
            d.call(D.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (dt) {
            S = dt;
          }
          d();
        }
      } catch (dt) {
        if (dt && S && typeof dt.stack == "string") {
          for (var E = dt.stack.split(`
`), H = S.stack.split(`
`), U = E.length - 1, W = H.length - 1; U >= 1 && W >= 0 && E[U] !== H[W]; )
            W--;
          for (; U >= 1 && W >= 0; U--, W--)
            if (E[U] !== H[W]) {
              if (U !== 1 || W !== 1)
                do
                  if (U--, W--, W < 0 || E[U] !== H[W]) {
                    var Q = `
` + E[U].replace(" at new ", " at ");
                    return d.displayName && Q.includes("<anonymous>") && (Q = Q.replace("<anonymous>", d.displayName)), typeof d == "function" && ut.set(d, Q), Q;
                  }
                while (U >= 1 && W >= 0);
              break;
            }
        }
      } finally {
        Vt = !1, ct.current = j, Pe(), Error.prepareStackTrace = M;
      }
      var Ft = d ? d.displayName || d.name : "", pr = Ft ? jt(Ft) : "";
      return typeof d == "function" && ut.set(d, pr), pr;
    }
    function Te(d, g, b) {
      return qt(d, !1);
    }
    function Yi(d) {
      var g = d.prototype;
      return !!(g && g.isReactComponent);
    }
    function we(d, g, b) {
      if (d == null)
        return "";
      if (typeof d == "function")
        return qt(d, Yi(d));
      if (typeof d == "string")
        return jt(d);
      switch (d) {
        case c:
          return jt("Suspense");
        case u:
          return jt("SuspenseList");
      }
      if (typeof d == "object")
        switch (d.$$typeof) {
          case l:
            return Te(d.render);
          case f:
            return we(d.type, g, b);
          case h: {
            var S = d, M = S._payload, j = S._init;
            try {
              return we(j(M), g, b);
            } catch {
            }
          }
        }
      return "";
    }
    var Ce = Object.prototype.hasOwnProperty, nr = {}, rr = P.ReactDebugCurrentFrame;
    function Se(d) {
      if (d) {
        var g = d._owner, b = we(d.type, d._source, g ? g.type : null);
        rr.setExtraStackFrame(b);
      } else
        rr.setExtraStackFrame(null);
    }
    function Hi(d, g, b, S, M) {
      {
        var j = Function.call.bind(Ce);
        for (var D in d)
          if (j(d, D)) {
            var E = void 0;
            try {
              if (typeof d[D] != "function") {
                var H = Error((S || "React class") + ": " + b + " type `" + D + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof d[D] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw H.name = "Invariant Violation", H;
              }
              E = d[D](g, D, S, b, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (U) {
              E = U;
            }
            E && !(E instanceof Error) && (Se(M), y("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", S || "React class", b, D, typeof E), Se(null)), E instanceof Error && !(E.message in nr) && (nr[E.message] = !0, Se(M), y("Failed %s type: %s", b, E.message), Se(null));
          }
      }
    }
    var Ki = Array.isArray;
    function Je(d) {
      return Ki(d);
    }
    function qi(d) {
      {
        var g = typeof Symbol == "function" && Symbol.toStringTag, b = g && d[Symbol.toStringTag] || d.constructor.name || "Object";
        return b;
      }
    }
    function Xi(d) {
      try {
        return sr(d), !1;
      } catch {
        return !0;
      }
    }
    function sr(d) {
      return "" + d;
    }
    function ir(d) {
      if (Xi(d))
        return y("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", qi(d)), sr(d);
    }
    var Xt = P.ReactCurrentOwner, Zi = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, or, ar, Qe;
    Qe = {};
    function Ji(d) {
      if (Ce.call(d, "ref")) {
        var g = Object.getOwnPropertyDescriptor(d, "ref").get;
        if (g && g.isReactWarning)
          return !1;
      }
      return d.ref !== void 0;
    }
    function Qi(d) {
      if (Ce.call(d, "key")) {
        var g = Object.getOwnPropertyDescriptor(d, "key").get;
        if (g && g.isReactWarning)
          return !1;
      }
      return d.key !== void 0;
    }
    function to(d, g) {
      if (typeof d.ref == "string" && Xt.current && g && Xt.current.stateNode !== g) {
        var b = G(Xt.current.type);
        Qe[b] || (y('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', G(Xt.current.type), d.ref), Qe[b] = !0);
      }
    }
    function eo(d, g) {
      {
        var b = function() {
          or || (or = !0, y("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", g));
        };
        b.isReactWarning = !0, Object.defineProperty(d, "key", {
          get: b,
          configurable: !0
        });
      }
    }
    function no(d, g) {
      {
        var b = function() {
          ar || (ar = !0, y("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", g));
        };
        b.isReactWarning = !0, Object.defineProperty(d, "ref", {
          get: b,
          configurable: !0
        });
      }
    }
    var ro = function(d, g, b, S, M, j, D) {
      var E = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: e,
        // Built-in properties that belong on the element
        type: d,
        key: g,
        ref: b,
        props: D,
        // Record the component responsible for creating this element.
        _owner: j
      };
      return E._store = {}, Object.defineProperty(E._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(E, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: S
      }), Object.defineProperty(E, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: M
      }), Object.freeze && (Object.freeze(E.props), Object.freeze(E)), E;
    };
    function so(d, g, b, S, M) {
      {
        var j, D = {}, E = null, H = null;
        b !== void 0 && (ir(b), E = "" + b), Qi(g) && (ir(g.key), E = "" + g.key), Ji(g) && (H = g.ref, to(g, M));
        for (j in g)
          Ce.call(g, j) && !Zi.hasOwnProperty(j) && (D[j] = g[j]);
        if (d && d.defaultProps) {
          var U = d.defaultProps;
          for (j in U)
            D[j] === void 0 && (D[j] = U[j]);
        }
        if (E || H) {
          var W = typeof d == "function" ? d.displayName || d.name || "Unknown" : d;
          E && eo(D, W), H && no(D, W);
        }
        return ro(d, E, H, M, S, Xt.current, D);
      }
    }
    var tn = P.ReactCurrentOwner, lr = P.ReactDebugCurrentFrame;
    function Ot(d) {
      if (d) {
        var g = d._owner, b = we(d.type, d._source, g ? g.type : null);
        lr.setExtraStackFrame(b);
      } else
        lr.setExtraStackFrame(null);
    }
    var en;
    en = !1;
    function nn(d) {
      return typeof d == "object" && d !== null && d.$$typeof === e;
    }
    function cr() {
      {
        if (tn.current) {
          var d = G(tn.current.type);
          if (d)
            return `

Check the render method of \`` + d + "`.";
        }
        return "";
      }
    }
    function io(d) {
      {
        if (d !== void 0) {
          var g = d.fileName.replace(/^.*[\\\/]/, ""), b = d.lineNumber;
          return `

Check your code at ` + g + ":" + b + ".";
        }
        return "";
      }
    }
    var ur = {};
    function oo(d) {
      {
        var g = cr();
        if (!g) {
          var b = typeof d == "string" ? d : d.displayName || d.name;
          b && (g = `

Check the top-level render call using <` + b + ">.");
        }
        return g;
      }
    }
    function fr(d, g) {
      {
        if (!d._store || d._store.validated || d.key != null)
          return;
        d._store.validated = !0;
        var b = oo(g);
        if (ur[b])
          return;
        ur[b] = !0;
        var S = "";
        d && d._owner && d._owner !== tn.current && (S = " It was passed a child from " + G(d._owner.type) + "."), Ot(d), y('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', b, S), Ot(null);
      }
    }
    function dr(d, g) {
      {
        if (typeof d != "object")
          return;
        if (Je(d))
          for (var b = 0; b < d.length; b++) {
            var S = d[b];
            nn(S) && fr(S, g);
          }
        else if (nn(d))
          d._store && (d._store.validated = !0);
        else if (d) {
          var M = T(d);
          if (typeof M == "function" && M !== d.entries)
            for (var j = M.call(d), D; !(D = j.next()).done; )
              nn(D.value) && fr(D.value, g);
        }
      }
    }
    function ao(d) {
      {
        var g = d.type;
        if (g == null || typeof g == "string")
          return;
        var b;
        if (typeof g == "function")
          b = g.propTypes;
        else if (typeof g == "object" && (g.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        g.$$typeof === f))
          b = g.propTypes;
        else
          return;
        if (b) {
          var S = G(g);
          Hi(b, d.props, "prop", S, d);
        } else if (g.PropTypes !== void 0 && !en) {
          en = !0;
          var M = G(g);
          y("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", M || "Unknown");
        }
        typeof g.getDefaultProps == "function" && !g.getDefaultProps.isReactClassApproved && y("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function lo(d) {
      {
        for (var g = Object.keys(d.props), b = 0; b < g.length; b++) {
          var S = g[b];
          if (S !== "children" && S !== "key") {
            Ot(d), y("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", S), Ot(null);
            break;
          }
        }
        d.ref !== null && (Ot(d), y("Invalid attribute `ref` supplied to `React.Fragment`."), Ot(null));
      }
    }
    function hr(d, g, b, S, M, j) {
      {
        var D = et(d);
        if (!D) {
          var E = "";
          (d === void 0 || typeof d == "object" && d !== null && Object.keys(d).length === 0) && (E += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var H = io(M);
          H ? E += H : E += cr();
          var U;
          d === null ? U = "null" : Je(d) ? U = "array" : d !== void 0 && d.$$typeof === e ? (U = "<" + (G(d.type) || "Unknown") + " />", E = " Did you accidentally export a JSX literal instead of a component?") : U = typeof d, y("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", U, E);
        }
        var W = so(d, g, b, M, j);
        if (W == null)
          return W;
        if (D) {
          var Q = g.children;
          if (Q !== void 0)
            if (S)
              if (Je(Q)) {
                for (var Ft = 0; Ft < Q.length; Ft++)
                  dr(Q[Ft], d);
                Object.freeze && Object.freeze(Q);
              } else
                y("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              dr(Q, d);
        }
        return d === r ? lo(W) : ao(W), W;
      }
    }
    function co(d, g, b) {
      return hr(d, g, b, !0);
    }
    function uo(d, g, b) {
      return hr(d, g, b, !1);
    }
    var fo = uo, ho = co;
    Jt.Fragment = r, Jt.jsx = fo, Jt.jsxs = ho;
  }()), Jt;
}
process.env.NODE_ENV === "production" ? vn.exports = Po() : vn.exports = To();
var A = vn.exports;
const Ss = Gt({
  transformPagePoint: (t) => t,
  isStatic: !1,
  reducedMotion: "never"
}), ze = Gt({}), Ge = Gt(null), Ye = typeof document < "u", je = Ye ? po : le, Vs = Gt({ strict: !1 });
function wo(t, e, n, r) {
  const { visualElement: s } = X(ze), o = X(Vs), i = X(Ge), a = X(Ss).reducedMotion, l = ht();
  r = r || o.renderer, !l.current && r && (l.current = r(t, {
    visualState: e,
    parent: s,
    props: n,
    presenceContext: i,
    blockInitialAnimation: i ? i.initial === !1 : !1,
    reducedMotionConfig: a
  }));
  const c = l.current;
  return Cs(() => {
    c && c.update(n, i);
  }), je(() => {
    c && c.render();
  }), le(() => {
    c && c.updateFeatures();
  }), (window.HandoffAppearAnimations ? je : le)(() => {
    c && c.animationState && c.animationState.animateChanges();
  }), c;
}
function It(t) {
  return typeof t == "object" && Object.prototype.hasOwnProperty.call(t, "current");
}
function Co(t, e, n) {
  return yn(
    (r) => {
      r && t.mount && t.mount(r), e && (r ? e.mount(r) : e.unmount()), n && (typeof n == "function" ? n(r) : It(n) && (n.current = r));
    },
    /**
     * Only pass a new ref callback to React if we've received a visual element
     * factory. Otherwise we'll be mounting/remounting every time externalRef
     * or other dependencies change.
     */
    [e]
  );
}
function ue(t) {
  return typeof t == "string" || Array.isArray(t);
}
function He(t) {
  return typeof t == "object" && typeof t.start == "function";
}
const Ln = [
  "animate",
  "whileInView",
  "whileFocus",
  "whileHover",
  "whileTap",
  "whileDrag",
  "exit"
], jn = ["initial", ...Ln];
function Ke(t) {
  return He(t.animate) || jn.some((e) => ue(t[e]));
}
function As(t) {
  return !!(Ke(t) || t.variants);
}
function So(t, e) {
  if (Ke(t)) {
    const { initial: n, animate: r } = t;
    return {
      initial: n === !1 || ue(n) ? n : void 0,
      animate: ue(r) ? r : void 0
    };
  }
  return t.inherit !== !1 ? e : {};
}
function Vo(t) {
  const { initial: e, animate: n } = So(t, X(ze));
  return $t(() => ({ initial: e, animate: n }), [yr(e), yr(n)]);
}
function yr(t) {
  return Array.isArray(t) ? t.join(" ") : t;
}
const vr = {
  animation: [
    "animate",
    "variants",
    "whileHover",
    "whileTap",
    "exit",
    "whileInView",
    "whileFocus",
    "whileDrag"
  ],
  exit: ["exit"],
  drag: ["drag", "dragControls"],
  focus: ["whileFocus"],
  hover: ["whileHover", "onHoverStart", "onHoverEnd"],
  tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
  pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
  inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
  layout: ["layout", "layoutId"]
}, fe = {};
for (const t in vr)
  fe[t] = {
    isEnabled: (e) => vr[t].some((n) => !!e[n])
  };
function Ao(t) {
  for (const e in t)
    fe[e] = {
      ...fe[e],
      ...t[e]
    };
}
const On = Gt({}), Rs = Gt({}), Ro = Symbol.for("motionComponentSymbol");
function Eo({ preloadedFeatures: t, createVisualElement: e, useRender: n, useVisualState: r, Component: s }) {
  t && Ao(t);
  function o(a, l) {
    let c;
    const u = {
      ...X(Ss),
      ...a,
      layoutId: Do(a)
    }, { isStatic: f } = u, h = Vo(a), p = r(a, f);
    if (!f && Ye) {
      h.visualElement = wo(s, p, u, e);
      const m = X(Rs), v = X(Vs).strict;
      h.visualElement && (c = h.visualElement.loadFeatures(
        // Note: Pass the full new combined props to correctly re-render dynamic feature components.
        u,
        v,
        t,
        m
      ));
    }
    return q.createElement(
      ze.Provider,
      { value: h },
      c && h.visualElement ? q.createElement(c, { visualElement: h.visualElement, ...u }) : null,
      n(s, a, Co(p, h.visualElement, l), p, f, h.visualElement)
    );
  }
  const i = mo(o);
  return i[Ro] = s, i;
}
function Do({ layoutId: t }) {
  const e = X(On).id;
  return e && t !== void 0 ? e + "-" + t : t;
}
function Mo(t) {
  function e(r, s = {}) {
    return Eo(t(r, s));
  }
  if (typeof Proxy > "u")
    return e;
  const n = /* @__PURE__ */ new Map();
  return new Proxy(e, {
    /**
     * Called when `motion` is referenced with a prop: `motion.div`, `motion.input` etc.
     * The prop name is passed through as `key` and we can use that to generate a `motion`
     * DOM component with that name.
     */
    get: (r, s) => (n.has(s) || n.set(s, e(s)), n.get(s))
  });
}
const ko = [
  "animate",
  "circle",
  "defs",
  "desc",
  "ellipse",
  "g",
  "image",
  "line",
  "filter",
  "marker",
  "mask",
  "metadata",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "rect",
  "stop",
  "switch",
  "symbol",
  "svg",
  "text",
  "tspan",
  "use",
  "view"
];
function Fn(t) {
  return (
    /**
     * If it's not a string, it's a custom React component. Currently we only support
     * HTML custom React components.
     */
    typeof t != "string" || /**
     * If it contains a dash, the element is a custom HTML webcomponent.
     */
    t.includes("-") ? !1 : (
      /**
       * If it's in our list of lowercase SVG tags, it's an SVG component
       */
      !!(ko.indexOf(t) > -1 || /**
       * If it contains a capital letter, it's an SVG component
       */
      /[A-Z]/.test(t))
    )
  );
}
const Oe = {};
function Lo(t) {
  Object.assign(Oe, t);
}
const pe = [
  "transformPerspective",
  "x",
  "y",
  "z",
  "translateX",
  "translateY",
  "translateZ",
  "scale",
  "scaleX",
  "scaleY",
  "rotate",
  "rotateX",
  "rotateY",
  "rotateZ",
  "skew",
  "skewX",
  "skewY"
], Mt = new Set(pe);
function Es(t, { layout: e, layoutId: n }) {
  return Mt.has(t) || t.startsWith("origin") || (e || n !== void 0) && (!!Oe[t] || t === "opacity");
}
const Z = (t) => !!(t && t.getVelocity), jo = {
  x: "translateX",
  y: "translateY",
  z: "translateZ",
  transformPerspective: "perspective"
}, Oo = pe.length;
function Fo(t, { enableHardwareAcceleration: e = !0, allowTransformNone: n = !0 }, r, s) {
  let o = "";
  for (let i = 0; i < Oo; i++) {
    const a = pe[i];
    if (t[a] !== void 0) {
      const l = jo[a] || a;
      o += `${l}(${t[a]}) `;
    }
  }
  return e && !t.z && (o += "translateZ(0)"), o = o.trim(), s ? o = s(t, r ? "" : o) : n && r && (o = "none"), o;
}
const Ds = (t) => (e) => typeof e == "string" && e.startsWith(t), Ms = Ds("--"), xn = Ds("var(--"), Bo = /var\s*\(\s*--[\w-]+(\s*,\s*(?:(?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)+)?\s*\)/g, Io = (t, e) => e && typeof t == "number" ? e.transform(t) : t, wt = (t, e, n) => Math.min(Math.max(n, t), e), kt = {
  test: (t) => typeof t == "number",
  parse: parseFloat,
  transform: (t) => t
}, se = {
  ...kt,
  transform: (t) => wt(0, 1, t)
}, Ve = {
  ...kt,
  default: 1
}, ie = (t) => Math.round(t * 1e5) / 1e5, qe = /(-)?([\d]*\.?[\d])+/g, ks = /(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))/gi, _o = /^(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))$/i;
function me(t) {
  return typeof t == "string";
}
const ge = (t) => ({
  test: (e) => me(e) && e.endsWith(t) && e.split(" ").length === 1,
  parse: parseFloat,
  transform: (e) => `${e}${t}`
}), xt = ge("deg"), at = ge("%"), C = ge("px"), No = ge("vh"), Uo = ge("vw"), xr = {
  ...at,
  parse: (t) => at.parse(t) / 100,
  transform: (t) => at.transform(t * 100)
}, br = {
  ...kt,
  transform: Math.round
}, Ls = {
  // Border props
  borderWidth: C,
  borderTopWidth: C,
  borderRightWidth: C,
  borderBottomWidth: C,
  borderLeftWidth: C,
  borderRadius: C,
  radius: C,
  borderTopLeftRadius: C,
  borderTopRightRadius: C,
  borderBottomRightRadius: C,
  borderBottomLeftRadius: C,
  // Positioning props
  width: C,
  maxWidth: C,
  height: C,
  maxHeight: C,
  size: C,
  top: C,
  right: C,
  bottom: C,
  left: C,
  // Spacing props
  padding: C,
  paddingTop: C,
  paddingRight: C,
  paddingBottom: C,
  paddingLeft: C,
  margin: C,
  marginTop: C,
  marginRight: C,
  marginBottom: C,
  marginLeft: C,
  // Transform props
  rotate: xt,
  rotateX: xt,
  rotateY: xt,
  rotateZ: xt,
  scale: Ve,
  scaleX: Ve,
  scaleY: Ve,
  scaleZ: Ve,
  skew: xt,
  skewX: xt,
  skewY: xt,
  distance: C,
  translateX: C,
  translateY: C,
  translateZ: C,
  x: C,
  y: C,
  z: C,
  perspective: C,
  transformPerspective: C,
  opacity: se,
  originX: xr,
  originY: xr,
  originZ: C,
  // Misc
  zIndex: br,
  // SVG
  fillOpacity: se,
  strokeOpacity: se,
  numOctaves: br
};
function Bn(t, e, n, r) {
  const { style: s, vars: o, transform: i, transformOrigin: a } = t;
  let l = !1, c = !1, u = !0;
  for (const f in e) {
    const h = e[f];
    if (Ms(f)) {
      o[f] = h;
      continue;
    }
    const p = Ls[f], m = Io(h, p);
    if (Mt.has(f)) {
      if (l = !0, i[f] = m, !u)
        continue;
      h !== (p.default || 0) && (u = !1);
    } else
      f.startsWith("origin") ? (c = !0, a[f] = m) : s[f] = m;
  }
  if (e.transform || (l || r ? s.transform = Fo(t.transform, n, u, r) : s.transform && (s.transform = "none")), c) {
    const { originX: f = "50%", originY: h = "50%", originZ: p = 0 } = a;
    s.transformOrigin = `${f} ${h} ${p}`;
  }
}
const In = () => ({
  style: {},
  transform: {},
  transformOrigin: {},
  vars: {}
});
function js(t, e, n) {
  for (const r in e)
    !Z(e[r]) && !Es(r, n) && (t[r] = e[r]);
}
function $o({ transformTemplate: t }, e, n) {
  return $t(() => {
    const r = In();
    return Bn(r, e, { enableHardwareAcceleration: !n }, t), Object.assign({}, r.vars, r.style);
  }, [e]);
}
function Wo(t, e, n) {
  const r = t.style || {}, s = {};
  return js(s, r, t), Object.assign(s, $o(t, e, n)), t.transformValues ? t.transformValues(s) : s;
}
function zo(t, e, n) {
  const r = {}, s = Wo(t, e, n);
  return t.drag && t.dragListener !== !1 && (r.draggable = !1, s.userSelect = s.WebkitUserSelect = s.WebkitTouchCallout = "none", s.touchAction = t.drag === !0 ? "none" : `pan-${t.drag === "x" ? "y" : "x"}`), t.tabIndex === void 0 && (t.onTap || t.onTapStart || t.whileTap) && (r.tabIndex = 0), r.style = s, r;
}
const Go = /* @__PURE__ */ new Set([
  "animate",
  "exit",
  "variants",
  "initial",
  "style",
  "values",
  "variants",
  "transition",
  "transformTemplate",
  "transformValues",
  "custom",
  "inherit",
  "onLayoutAnimationStart",
  "onLayoutAnimationComplete",
  "onLayoutMeasure",
  "onBeforeLayoutMeasure",
  "onAnimationStart",
  "onAnimationComplete",
  "onUpdate",
  "onDragStart",
  "onDrag",
  "onDragEnd",
  "onMeasureDragConstraints",
  "onDirectionLock",
  "onDragTransitionEnd",
  "_dragX",
  "_dragY",
  "onHoverStart",
  "onHoverEnd",
  "onViewportEnter",
  "onViewportLeave",
  "ignoreStrict",
  "viewport"
]);
function Fe(t) {
  return t.startsWith("while") || t.startsWith("drag") && t !== "draggable" || t.startsWith("layout") || t.startsWith("onTap") || t.startsWith("onPan") || Go.has(t);
}
let Os = (t) => !Fe(t);
function Yo(t) {
  t && (Os = (e) => e.startsWith("on") ? !Fe(e) : t(e));
}
try {
  Yo(require("@emotion/is-prop-valid").default);
} catch {
}
function Ho(t, e, n) {
  const r = {};
  for (const s in t)
    s === "values" && typeof t.values == "object" || (Os(s) || n === !0 && Fe(s) || !e && !Fe(s) || // If trying to use native HTML drag events, forward drag listeners
    t.draggable && s.startsWith("onDrag")) && (r[s] = t[s]);
  return r;
}
function Pr(t, e, n) {
  return typeof t == "string" ? t : C.transform(e + n * t);
}
function Ko(t, e, n) {
  const r = Pr(e, t.x, t.width), s = Pr(n, t.y, t.height);
  return `${r} ${s}`;
}
const qo = {
  offset: "stroke-dashoffset",
  array: "stroke-dasharray"
}, Xo = {
  offset: "strokeDashoffset",
  array: "strokeDasharray"
};
function Zo(t, e, n = 1, r = 0, s = !0) {
  t.pathLength = 1;
  const o = s ? qo : Xo;
  t[o.offset] = C.transform(-r);
  const i = C.transform(e), a = C.transform(n);
  t[o.array] = `${i} ${a}`;
}
function _n(t, {
  attrX: e,
  attrY: n,
  attrScale: r,
  originX: s,
  originY: o,
  pathLength: i,
  pathSpacing: a = 1,
  pathOffset: l = 0,
  // This is object creation, which we try to avoid per-frame.
  ...c
}, u, f, h) {
  if (Bn(t, c, u, h), f) {
    t.style.viewBox && (t.attrs.viewBox = t.style.viewBox);
    return;
  }
  t.attrs = t.style, t.style = {};
  const { attrs: p, style: m, dimensions: v } = t;
  p.transform && (v && (m.transform = p.transform), delete p.transform), v && (s !== void 0 || o !== void 0 || m.transform) && (m.transformOrigin = Ko(v, s !== void 0 ? s : 0.5, o !== void 0 ? o : 0.5)), e !== void 0 && (p.x = e), n !== void 0 && (p.y = n), r !== void 0 && (p.scale = r), i !== void 0 && Zo(p, i, a, l, !1);
}
const Fs = () => ({
  ...In(),
  attrs: {}
}), Nn = (t) => typeof t == "string" && t.toLowerCase() === "svg";
function Jo(t, e, n, r) {
  const s = $t(() => {
    const o = Fs();
    return _n(o, e, { enableHardwareAcceleration: !1 }, Nn(r), t.transformTemplate), {
      ...o.attrs,
      style: { ...o.style }
    };
  }, [e]);
  if (t.style) {
    const o = {};
    js(o, t.style, t), s.style = { ...o, ...s.style };
  }
  return s;
}
function Qo(t = !1) {
  return (n, r, s, { latestValues: o }, i) => {
    const l = (Fn(n) ? Jo : zo)(r, o, i, n), u = {
      ...Ho(r, typeof n == "string", t),
      ...l,
      ref: s
    }, { children: f } = r, h = $t(() => Z(f) ? f.get() : f, [f]);
    return go(n, {
      ...u,
      children: h
    });
  };
}
const Un = (t) => t.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
function Bs(t, { style: e, vars: n }, r, s) {
  Object.assign(t.style, e, s && s.getProjectionStyles(r));
  for (const o in n)
    t.style.setProperty(o, n[o]);
}
const Is = /* @__PURE__ */ new Set([
  "baseFrequency",
  "diffuseConstant",
  "kernelMatrix",
  "kernelUnitLength",
  "keySplines",
  "keyTimes",
  "limitingConeAngle",
  "markerHeight",
  "markerWidth",
  "numOctaves",
  "targetX",
  "targetY",
  "surfaceScale",
  "specularConstant",
  "specularExponent",
  "stdDeviation",
  "tableValues",
  "viewBox",
  "gradientTransform",
  "pathLength",
  "startOffset",
  "textLength",
  "lengthAdjust"
]);
function _s(t, e, n, r) {
  Bs(t, e, void 0, r);
  for (const s in e.attrs)
    t.setAttribute(Is.has(s) ? s : Un(s), e.attrs[s]);
}
function $n(t, e) {
  const { style: n } = t, r = {};
  for (const s in n)
    (Z(n[s]) || e.style && Z(e.style[s]) || Es(s, t)) && (r[s] = n[s]);
  return r;
}
function Ns(t, e) {
  const n = $n(t, e);
  for (const r in t)
    if (Z(t[r]) || Z(e[r])) {
      const s = pe.indexOf(r) !== -1 ? "attr" + r.charAt(0).toUpperCase() + r.substring(1) : r;
      n[s] = t[r];
    }
  return n;
}
function Wn(t, e, n, r = {}, s = {}) {
  return typeof e == "function" && (e = e(n !== void 0 ? n : t.custom, r, s)), typeof e == "string" && (e = t.variants && t.variants[e]), typeof e == "function" && (e = e(n !== void 0 ? n : t.custom, r, s)), e;
}
function Us(t) {
  const e = ht(null);
  return e.current === null && (e.current = t()), e.current;
}
const Be = (t) => Array.isArray(t), ta = (t) => !!(t && typeof t == "object" && t.mix && t.toValue), ea = (t) => Be(t) ? t[t.length - 1] || 0 : t;
function ke(t) {
  const e = Z(t) ? t.get() : t;
  return ta(e) ? e.toValue() : e;
}
function na({ scrapeMotionValuesFromProps: t, createRenderState: e, onMount: n }, r, s, o) {
  const i = {
    latestValues: ra(r, s, o, t),
    renderState: e()
  };
  return n && (i.mount = (a) => n(r, a, i)), i;
}
const $s = (t) => (e, n) => {
  const r = X(ze), s = X(Ge), o = () => na(t, e, r, s);
  return n ? o() : Us(o);
};
function ra(t, e, n, r) {
  const s = {}, o = r(t, {});
  for (const h in o)
    s[h] = ke(o[h]);
  let { initial: i, animate: a } = t;
  const l = Ke(t), c = As(t);
  e && c && !l && t.inherit !== !1 && (i === void 0 && (i = e.initial), a === void 0 && (a = e.animate));
  let u = n ? n.initial === !1 : !1;
  u = u || i === !1;
  const f = u ? a : i;
  return f && typeof f != "boolean" && !He(f) && (Array.isArray(f) ? f : [f]).forEach((p) => {
    const m = Wn(t, p);
    if (!m)
      return;
    const { transitionEnd: v, transition: T, ...P } = m;
    for (const y in P) {
      let x = P[y];
      if (Array.isArray(x)) {
        const w = u ? x.length - 1 : 0;
        x = x[w];
      }
      x !== null && (s[y] = x);
    }
    for (const y in v)
      s[y] = v[y];
  }), s;
}
const sa = {
  useVisualState: $s({
    scrapeMotionValuesFromProps: Ns,
    createRenderState: Fs,
    onMount: (t, e, { renderState: n, latestValues: r }) => {
      try {
        n.dimensions = typeof e.getBBox == "function" ? e.getBBox() : e.getBoundingClientRect();
      } catch {
        n.dimensions = {
          x: 0,
          y: 0,
          width: 0,
          height: 0
        };
      }
      _n(n, r, { enableHardwareAcceleration: !1 }, Nn(e.tagName), t.transformTemplate), _s(e, n);
    }
  })
}, ia = {
  useVisualState: $s({
    scrapeMotionValuesFromProps: $n,
    createRenderState: In
  })
};
function oa(t, { forwardMotionProps: e = !1 }, n, r) {
  return {
    ...Fn(t) ? sa : ia,
    preloadedFeatures: n,
    useRender: Qo(e),
    createVisualElement: r,
    Component: t
  };
}
function pt(t, e, n, r = { passive: !0 }) {
  return t.addEventListener(e, n, r), () => t.removeEventListener(e, n);
}
const Ws = (t) => t.pointerType === "mouse" ? typeof t.button != "number" || t.button <= 0 : t.isPrimary !== !1;
function Xe(t, e = "page") {
  return {
    point: {
      x: t[e + "X"],
      y: t[e + "Y"]
    }
  };
}
const aa = (t) => (e) => Ws(e) && t(e, Xe(e));
function mt(t, e, n, r) {
  return pt(t, e, aa(n), r);
}
const la = (t, e) => (n) => e(t(n)), Pt = (...t) => t.reduce(la);
function zs(t) {
  let e = null;
  return () => {
    const n = () => {
      e = null;
    };
    return e === null ? (e = t, n) : !1;
  };
}
const Tr = zs("dragHorizontal"), wr = zs("dragVertical");
function Gs(t) {
  let e = !1;
  if (t === "y")
    e = wr();
  else if (t === "x")
    e = Tr();
  else {
    const n = Tr(), r = wr();
    n && r ? e = () => {
      n(), r();
    } : (n && n(), r && r());
  }
  return e;
}
function Ys() {
  const t = Gs(!0);
  return t ? (t(), !1) : !0;
}
class St {
  constructor(e) {
    this.isMounted = !1, this.node = e;
  }
  update() {
  }
}
const $ = (t) => t;
function ca(t) {
  let e = [], n = [], r = 0, s = !1, o = !1;
  const i = /* @__PURE__ */ new WeakSet(), a = {
    /**
     * Schedule a process to run on the next frame.
     */
    schedule: (l, c = !1, u = !1) => {
      const f = u && s, h = f ? e : n;
      return c && i.add(l), h.indexOf(l) === -1 && (h.push(l), f && s && (r = e.length)), l;
    },
    /**
     * Cancel the provided callback from running on the next frame.
     */
    cancel: (l) => {
      const c = n.indexOf(l);
      c !== -1 && n.splice(c, 1), i.delete(l);
    },
    /**
     * Execute all schedule callbacks.
     */
    process: (l) => {
      if (s) {
        o = !0;
        return;
      }
      if (s = !0, [e, n] = [n, e], n.length = 0, r = e.length, r)
        for (let c = 0; c < r; c++) {
          const u = e[c];
          u(l), i.has(u) && (a.schedule(u), t());
        }
      s = !1, o && (o = !1, a.process(l));
    }
  };
  return a;
}
const Ae = [
  "prepare",
  "read",
  "update",
  "preRender",
  "render",
  "postRender"
], ua = 40;
function fa(t, e) {
  let n = !1, r = !0;
  const s = {
    delta: 0,
    timestamp: 0,
    isProcessing: !1
  }, o = Ae.reduce((f, h) => (f[h] = ca(() => n = !0), f), {}), i = (f) => o[f].process(s), a = (f) => {
    n = !1, s.delta = r ? 1e3 / 60 : Math.max(Math.min(f - s.timestamp, ua), 1), s.timestamp = f, s.isProcessing = !0, Ae.forEach(i), s.isProcessing = !1, n && e && (r = !1, t(a));
  }, l = () => {
    n = !0, r = !0, s.isProcessing || t(a);
  };
  return { schedule: Ae.reduce((f, h) => {
    const p = o[h];
    return f[h] = (m, v = !1, T = !1) => (n || l(), p.schedule(m, v, T)), f;
  }, {}), cancel: (f) => Ae.forEach((h) => o[h].cancel(f)), state: s, steps: o };
}
const { schedule: I, cancel: yt, state: Y, steps: rn } = fa(typeof requestAnimationFrame < "u" ? requestAnimationFrame : $, !0);
function Cr(t, e) {
  const n = "pointer" + (e ? "enter" : "leave"), r = "onHover" + (e ? "Start" : "End"), s = (o, i) => {
    if (o.type === "touch" || Ys())
      return;
    const a = t.getProps();
    t.animationState && a.whileHover && t.animationState.setActive("whileHover", e), a[r] && I.update(() => a[r](o, i));
  };
  return mt(t.current, n, s, {
    passive: !t.getProps()[r]
  });
}
class da extends St {
  mount() {
    this.unmount = Pt(Cr(this.node, !0), Cr(this.node, !1));
  }
  unmount() {
  }
}
class ha extends St {
  constructor() {
    super(...arguments), this.isActive = !1;
  }
  onFocus() {
    let e = !1;
    try {
      e = this.node.current.matches(":focus-visible");
    } catch {
      e = !0;
    }
    !e || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !0), this.isActive = !0);
  }
  onBlur() {
    !this.isActive || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !1), this.isActive = !1);
  }
  mount() {
    this.unmount = Pt(pt(this.node.current, "focus", () => this.onFocus()), pt(this.node.current, "blur", () => this.onBlur()));
  }
  unmount() {
  }
}
const Hs = (t, e) => e ? t === e ? !0 : Hs(t, e.parentElement) : !1;
function sn(t, e) {
  if (!e)
    return;
  const n = new PointerEvent("pointer" + t);
  e(n, Xe(n));
}
class pa extends St {
  constructor() {
    super(...arguments), this.removeStartListeners = $, this.removeEndListeners = $, this.removeAccessibleListeners = $, this.startPointerPress = (e, n) => {
      if (this.removeEndListeners(), this.isPressing)
        return;
      const r = this.node.getProps(), o = mt(window, "pointerup", (a, l) => {
        if (!this.checkPressEnd())
          return;
        const { onTap: c, onTapCancel: u } = this.node.getProps();
        I.update(() => {
          Hs(this.node.current, a.target) ? c && c(a, l) : u && u(a, l);
        });
      }, { passive: !(r.onTap || r.onPointerUp) }), i = mt(window, "pointercancel", (a, l) => this.cancelPress(a, l), { passive: !(r.onTapCancel || r.onPointerCancel) });
      this.removeEndListeners = Pt(o, i), this.startPress(e, n);
    }, this.startAccessiblePress = () => {
      const e = (o) => {
        if (o.key !== "Enter" || this.isPressing)
          return;
        const i = (a) => {
          a.key !== "Enter" || !this.checkPressEnd() || sn("up", (l, c) => {
            const { onTap: u } = this.node.getProps();
            u && I.update(() => u(l, c));
          });
        };
        this.removeEndListeners(), this.removeEndListeners = pt(this.node.current, "keyup", i), sn("down", (a, l) => {
          this.startPress(a, l);
        });
      }, n = pt(this.node.current, "keydown", e), r = () => {
        this.isPressing && sn("cancel", (o, i) => this.cancelPress(o, i));
      }, s = pt(this.node.current, "blur", r);
      this.removeAccessibleListeners = Pt(n, s);
    };
  }
  startPress(e, n) {
    this.isPressing = !0;
    const { onTapStart: r, whileTap: s } = this.node.getProps();
    s && this.node.animationState && this.node.animationState.setActive("whileTap", !0), r && I.update(() => r(e, n));
  }
  checkPressEnd() {
    return this.removeEndListeners(), this.isPressing = !1, this.node.getProps().whileTap && this.node.animationState && this.node.animationState.setActive("whileTap", !1), !Ys();
  }
  cancelPress(e, n) {
    if (!this.checkPressEnd())
      return;
    const { onTapCancel: r } = this.node.getProps();
    r && I.update(() => r(e, n));
  }
  mount() {
    const e = this.node.getProps(), n = mt(this.node.current, "pointerdown", this.startPointerPress, { passive: !(e.onTapStart || e.onPointerStart) }), r = pt(this.node.current, "focus", this.startAccessiblePress);
    this.removeStartListeners = Pt(n, r);
  }
  unmount() {
    this.removeStartListeners(), this.removeEndListeners(), this.removeAccessibleListeners();
  }
}
const bn = /* @__PURE__ */ new WeakMap(), on = /* @__PURE__ */ new WeakMap(), ma = (t) => {
  const e = bn.get(t.target);
  e && e(t);
}, ga = (t) => {
  t.forEach(ma);
};
function ya({ root: t, ...e }) {
  const n = t || document;
  on.has(n) || on.set(n, {});
  const r = on.get(n), s = JSON.stringify(e);
  return r[s] || (r[s] = new IntersectionObserver(ga, { root: t, ...e })), r[s];
}
function va(t, e, n) {
  const r = ya(e);
  return bn.set(t, n), r.observe(t), () => {
    bn.delete(t), r.unobserve(t);
  };
}
const xa = {
  some: 0,
  all: 1
};
class ba extends St {
  constructor() {
    super(...arguments), this.hasEnteredView = !1, this.isInView = !1;
  }
  startObserver() {
    this.unmount();
    const { viewport: e = {} } = this.node.getProps(), { root: n, margin: r, amount: s = "some", once: o } = e, i = {
      root: n ? n.current : void 0,
      rootMargin: r,
      threshold: typeof s == "number" ? s : xa[s]
    }, a = (l) => {
      const { isIntersecting: c } = l;
      if (this.isInView === c || (this.isInView = c, o && !c && this.hasEnteredView))
        return;
      c && (this.hasEnteredView = !0), this.node.animationState && this.node.animationState.setActive("whileInView", c);
      const { onViewportEnter: u, onViewportLeave: f } = this.node.getProps(), h = c ? u : f;
      h && h(l);
    };
    return va(this.node.current, i, a);
  }
  mount() {
    this.startObserver();
  }
  update() {
    if (typeof IntersectionObserver > "u")
      return;
    const { props: e, prevProps: n } = this.node;
    ["amount", "margin", "root"].some(Pa(e, n)) && this.startObserver();
  }
  unmount() {
  }
}
function Pa({ viewport: t = {} }, { viewport: e = {} } = {}) {
  return (n) => t[n] !== e[n];
}
const Ta = {
  inView: {
    Feature: ba
  },
  tap: {
    Feature: pa
  },
  focus: {
    Feature: ha
  },
  hover: {
    Feature: da
  }
};
function Ks(t, e) {
  if (!Array.isArray(e))
    return !1;
  const n = e.length;
  if (n !== t.length)
    return !1;
  for (let r = 0; r < n; r++)
    if (e[r] !== t[r])
      return !1;
  return !0;
}
function wa(t) {
  const e = {};
  return t.values.forEach((n, r) => e[r] = n.get()), e;
}
function Ca(t) {
  const e = {};
  return t.values.forEach((n, r) => e[r] = n.getVelocity()), e;
}
function Ze(t, e, n) {
  const r = t.getProps();
  return Wn(r, e, n !== void 0 ? n : r.custom, wa(t), Ca(t));
}
const Sa = "framerAppearId", Va = "data-" + Un(Sa);
let ye = $, it = $;
process.env.NODE_ENV !== "production" && (ye = (t, e) => {
  !t && typeof console < "u" && console.warn(e);
}, it = (t, e) => {
  if (!t)
    throw new Error(e);
});
const Tt = (t) => t * 1e3, gt = (t) => t / 1e3, Aa = {
  current: !1
}, qs = (t) => Array.isArray(t) && typeof t[0] == "number";
function Xs(t) {
  return !!(!t || typeof t == "string" && Zs[t] || qs(t) || Array.isArray(t) && t.every(Xs));
}
const ne = ([t, e, n, r]) => `cubic-bezier(${t}, ${e}, ${n}, ${r})`, Zs = {
  linear: "linear",
  ease: "ease",
  easeIn: "ease-in",
  easeOut: "ease-out",
  easeInOut: "ease-in-out",
  circIn: ne([0, 0.65, 0.55, 1]),
  circOut: ne([0.55, 0, 1, 0.45]),
  backIn: ne([0.31, 0.01, 0.66, -0.59]),
  backOut: ne([0.33, 1.53, 0.69, 0.99])
};
function Js(t) {
  if (t)
    return qs(t) ? ne(t) : Array.isArray(t) ? t.map(Js) : Zs[t];
}
function Ra(t, e, n, { delay: r = 0, duration: s, repeat: o = 0, repeatType: i = "loop", ease: a, times: l } = {}) {
  const c = { [e]: n };
  l && (c.offset = l);
  const u = Js(a);
  return Array.isArray(u) && (c.easing = u), t.animate(c, {
    delay: r,
    duration: s,
    easing: Array.isArray(u) ? "linear" : u,
    fill: "both",
    iterations: o + 1,
    direction: i === "reverse" ? "alternate" : "normal"
  });
}
function Ea(t, { repeat: e, repeatType: n = "loop" }) {
  const r = e && n !== "loop" && e % 2 === 1 ? 0 : t.length - 1;
  return t[r];
}
const Qs = (t, e, n) => (((1 - 3 * n + 3 * e) * t + (3 * n - 6 * e)) * t + 3 * e) * t, Da = 1e-7, Ma = 12;
function ka(t, e, n, r, s) {
  let o, i, a = 0;
  do
    i = e + (n - e) / 2, o = Qs(i, r, s) - t, o > 0 ? n = i : e = i;
  while (Math.abs(o) > Da && ++a < Ma);
  return i;
}
function ve(t, e, n, r) {
  if (t === e && n === r)
    return $;
  const s = (o) => ka(o, 0, 1, t, n);
  return (o) => o === 0 || o === 1 ? o : Qs(s(o), e, r);
}
const La = ve(0.42, 0, 1, 1), ja = ve(0, 0, 0.58, 1), ti = ve(0.42, 0, 0.58, 1), Oa = (t) => Array.isArray(t) && typeof t[0] != "number", ei = (t) => (e) => e <= 0.5 ? t(2 * e) / 2 : (2 - t(2 * (1 - e))) / 2, ni = (t) => (e) => 1 - t(1 - e), ri = (t) => 1 - Math.sin(Math.acos(t)), zn = ni(ri), Fa = ei(zn), si = ve(0.33, 1.53, 0.69, 0.99), Gn = ni(si), Ba = ei(Gn), Ia = (t) => (t *= 2) < 1 ? 0.5 * Gn(t) : 0.5 * (2 - Math.pow(2, -10 * (t - 1))), Sr = {
  linear: $,
  easeIn: La,
  easeInOut: ti,
  easeOut: ja,
  circIn: ri,
  circInOut: Fa,
  circOut: zn,
  backIn: Gn,
  backInOut: Ba,
  backOut: si,
  anticipate: Ia
}, Vr = (t) => {
  if (Array.isArray(t)) {
    it(t.length === 4, "Cubic bezier arrays must contain four numerical values.");
    const [e, n, r, s] = t;
    return ve(e, n, r, s);
  } else if (typeof t == "string")
    return it(Sr[t] !== void 0, `Invalid easing type '${t}'`), Sr[t];
  return t;
}, Yn = (t, e) => (n) => !!(me(n) && _o.test(n) && n.startsWith(t) || e && Object.prototype.hasOwnProperty.call(n, e)), ii = (t, e, n) => (r) => {
  if (!me(r))
    return r;
  const [s, o, i, a] = r.match(qe);
  return {
    [t]: parseFloat(s),
    [e]: parseFloat(o),
    [n]: parseFloat(i),
    alpha: a !== void 0 ? parseFloat(a) : 1
  };
}, _a = (t) => wt(0, 255, t), an = {
  ...kt,
  transform: (t) => Math.round(_a(t))
}, Dt = {
  test: Yn("rgb", "red"),
  parse: ii("red", "green", "blue"),
  transform: ({ red: t, green: e, blue: n, alpha: r = 1 }) => "rgba(" + an.transform(t) + ", " + an.transform(e) + ", " + an.transform(n) + ", " + ie(se.transform(r)) + ")"
};
function Na(t) {
  let e = "", n = "", r = "", s = "";
  return t.length > 5 ? (e = t.substring(1, 3), n = t.substring(3, 5), r = t.substring(5, 7), s = t.substring(7, 9)) : (e = t.substring(1, 2), n = t.substring(2, 3), r = t.substring(3, 4), s = t.substring(4, 5), e += e, n += n, r += r, s += s), {
    red: parseInt(e, 16),
    green: parseInt(n, 16),
    blue: parseInt(r, 16),
    alpha: s ? parseInt(s, 16) / 255 : 1
  };
}
const Pn = {
  test: Yn("#"),
  parse: Na,
  transform: Dt.transform
}, _t = {
  test: Yn("hsl", "hue"),
  parse: ii("hue", "saturation", "lightness"),
  transform: ({ hue: t, saturation: e, lightness: n, alpha: r = 1 }) => "hsla(" + Math.round(t) + ", " + at.transform(ie(e)) + ", " + at.transform(ie(n)) + ", " + ie(se.transform(r)) + ")"
}, K = {
  test: (t) => Dt.test(t) || Pn.test(t) || _t.test(t),
  parse: (t) => Dt.test(t) ? Dt.parse(t) : _t.test(t) ? _t.parse(t) : Pn.parse(t),
  transform: (t) => me(t) ? t : t.hasOwnProperty("red") ? Dt.transform(t) : _t.transform(t)
}, _ = (t, e, n) => -n * t + n * e + t;
function ln(t, e, n) {
  return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? t + (e - t) * 6 * n : n < 1 / 2 ? e : n < 2 / 3 ? t + (e - t) * (2 / 3 - n) * 6 : t;
}
function Ua({ hue: t, saturation: e, lightness: n, alpha: r }) {
  t /= 360, e /= 100, n /= 100;
  let s = 0, o = 0, i = 0;
  if (!e)
    s = o = i = n;
  else {
    const a = n < 0.5 ? n * (1 + e) : n + e - n * e, l = 2 * n - a;
    s = ln(l, a, t + 1 / 3), o = ln(l, a, t), i = ln(l, a, t - 1 / 3);
  }
  return {
    red: Math.round(s * 255),
    green: Math.round(o * 255),
    blue: Math.round(i * 255),
    alpha: r
  };
}
const cn = (t, e, n) => {
  const r = t * t;
  return Math.sqrt(Math.max(0, n * (e * e - r) + r));
}, $a = [Pn, Dt, _t], Wa = (t) => $a.find((e) => e.test(t));
function Ar(t) {
  const e = Wa(t);
  it(!!e, `'${t}' is not an animatable color. Use the equivalent color code instead.`);
  let n = e.parse(t);
  return e === _t && (n = Ua(n)), n;
}
const oi = (t, e) => {
  const n = Ar(t), r = Ar(e), s = { ...n };
  return (o) => (s.red = cn(n.red, r.red, o), s.green = cn(n.green, r.green, o), s.blue = cn(n.blue, r.blue, o), s.alpha = _(n.alpha, r.alpha, o), Dt.transform(s));
};
function za(t) {
  var e, n;
  return isNaN(t) && me(t) && (((e = t.match(qe)) === null || e === void 0 ? void 0 : e.length) || 0) + (((n = t.match(ks)) === null || n === void 0 ? void 0 : n.length) || 0) > 0;
}
const ai = {
  regex: Bo,
  countKey: "Vars",
  token: "${v}",
  parse: $
}, li = {
  regex: ks,
  countKey: "Colors",
  token: "${c}",
  parse: K.parse
}, ci = {
  regex: qe,
  countKey: "Numbers",
  token: "${n}",
  parse: kt.parse
};
function un(t, { regex: e, countKey: n, token: r, parse: s }) {
  const o = t.tokenised.match(e);
  o && (t["num" + n] = o.length, t.tokenised = t.tokenised.replace(e, r), t.values.push(...o.map(s)));
}
function Ie(t) {
  const e = t.toString(), n = {
    value: e,
    tokenised: e,
    values: [],
    numVars: 0,
    numColors: 0,
    numNumbers: 0
  };
  return n.value.includes("var(--") && un(n, ai), un(n, li), un(n, ci), n;
}
function ui(t) {
  return Ie(t).values;
}
function fi(t) {
  const { values: e, numColors: n, numVars: r, tokenised: s } = Ie(t), o = e.length;
  return (i) => {
    let a = s;
    for (let l = 0; l < o; l++)
      l < r ? a = a.replace(ai.token, i[l]) : l < r + n ? a = a.replace(li.token, K.transform(i[l])) : a = a.replace(ci.token, ie(i[l]));
    return a;
  };
}
const Ga = (t) => typeof t == "number" ? 0 : t;
function Ya(t) {
  const e = ui(t);
  return fi(t)(e.map(Ga));
}
const Ct = {
  test: za,
  parse: ui,
  createTransformer: fi,
  getAnimatableNone: Ya
}, di = (t, e) => (n) => `${n > 0 ? e : t}`;
function hi(t, e) {
  return typeof t == "number" ? (n) => _(t, e, n) : K.test(t) ? oi(t, e) : t.startsWith("var(") ? di(t, e) : mi(t, e);
}
const pi = (t, e) => {
  const n = [...t], r = n.length, s = t.map((o, i) => hi(o, e[i]));
  return (o) => {
    for (let i = 0; i < r; i++)
      n[i] = s[i](o);
    return n;
  };
}, Ha = (t, e) => {
  const n = { ...t, ...e }, r = {};
  for (const s in n)
    t[s] !== void 0 && e[s] !== void 0 && (r[s] = hi(t[s], e[s]));
  return (s) => {
    for (const o in r)
      n[o] = r[o](s);
    return n;
  };
}, mi = (t, e) => {
  const n = Ct.createTransformer(e), r = Ie(t), s = Ie(e);
  return r.numVars === s.numVars && r.numColors === s.numColors && r.numNumbers >= s.numNumbers ? Pt(pi(r.values, s.values), n) : (ye(!0, `Complex values '${t}' and '${e}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`), di(t, e));
}, de = (t, e, n) => {
  const r = e - t;
  return r === 0 ? 1 : (n - t) / r;
}, Rr = (t, e) => (n) => _(t, e, n);
function Ka(t) {
  return typeof t == "number" ? Rr : typeof t == "string" ? K.test(t) ? oi : mi : Array.isArray(t) ? pi : typeof t == "object" ? Ha : Rr;
}
function qa(t, e, n) {
  const r = [], s = n || Ka(t[0]), o = t.length - 1;
  for (let i = 0; i < o; i++) {
    let a = s(t[i], t[i + 1]);
    if (e) {
      const l = Array.isArray(e) ? e[i] || $ : e;
      a = Pt(l, a);
    }
    r.push(a);
  }
  return r;
}
function gi(t, e, { clamp: n = !0, ease: r, mixer: s } = {}) {
  const o = t.length;
  if (it(o === e.length, "Both input and output ranges must be the same length"), o === 1)
    return () => e[0];
  t[0] > t[o - 1] && (t = [...t].reverse(), e = [...e].reverse());
  const i = qa(e, r, s), a = i.length, l = (c) => {
    let u = 0;
    if (a > 1)
      for (; u < t.length - 2 && !(c < t[u + 1]); u++)
        ;
    const f = de(t[u], t[u + 1], c);
    return i[u](f);
  };
  return n ? (c) => l(wt(t[0], t[o - 1], c)) : l;
}
function Xa(t, e) {
  const n = t[t.length - 1];
  for (let r = 1; r <= e; r++) {
    const s = de(0, e, r);
    t.push(_(n, 1, s));
  }
}
function Za(t) {
  const e = [0];
  return Xa(e, t.length - 1), e;
}
function Ja(t, e) {
  return t.map((n) => n * e);
}
function Qa(t, e) {
  return t.map(() => e || ti).splice(0, t.length - 1);
}
function _e({ duration: t = 300, keyframes: e, times: n, ease: r = "easeInOut" }) {
  const s = Oa(r) ? r.map(Vr) : Vr(r), o = {
    done: !1,
    value: e[0]
  }, i = Ja(
    // Only use the provided offsets if they're the correct length
    // TODO Maybe we should warn here if there's a length mismatch
    n && n.length === e.length ? n : Za(e),
    t
  ), a = gi(i, e, {
    ease: Array.isArray(s) ? s : Qa(e, s)
  });
  return {
    calculatedDuration: t,
    next: (l) => (o.value = a(l), o.done = l >= t, o)
  };
}
function yi(t, e) {
  return e ? t * (1e3 / e) : 0;
}
const tl = 5;
function vi(t, e, n) {
  const r = Math.max(e - tl, 0);
  return yi(n - t(r), e - r);
}
const fn = 1e-3, el = 0.01, Er = 10, nl = 0.05, rl = 1;
function sl({ duration: t = 800, bounce: e = 0.25, velocity: n = 0, mass: r = 1 }) {
  let s, o;
  ye(t <= Tt(Er), "Spring duration must be 10 seconds or less");
  let i = 1 - e;
  i = wt(nl, rl, i), t = wt(el, Er, gt(t)), i < 1 ? (s = (c) => {
    const u = c * i, f = u * t, h = u - n, p = Tn(c, i), m = Math.exp(-f);
    return fn - h / p * m;
  }, o = (c) => {
    const f = c * i * t, h = f * n + n, p = Math.pow(i, 2) * Math.pow(c, 2) * t, m = Math.exp(-f), v = Tn(Math.pow(c, 2), i);
    return (-s(c) + fn > 0 ? -1 : 1) * ((h - p) * m) / v;
  }) : (s = (c) => {
    const u = Math.exp(-c * t), f = (c - n) * t + 1;
    return -fn + u * f;
  }, o = (c) => {
    const u = Math.exp(-c * t), f = (n - c) * (t * t);
    return u * f;
  });
  const a = 5 / t, l = ol(s, o, a);
  if (t = Tt(t), isNaN(l))
    return {
      stiffness: 100,
      damping: 10,
      duration: t
    };
  {
    const c = Math.pow(l, 2) * r;
    return {
      stiffness: c,
      damping: i * 2 * Math.sqrt(r * c),
      duration: t
    };
  }
}
const il = 12;
function ol(t, e, n) {
  let r = n;
  for (let s = 1; s < il; s++)
    r = r - t(r) / e(r);
  return r;
}
function Tn(t, e) {
  return t * Math.sqrt(1 - e * e);
}
const al = ["duration", "bounce"], ll = ["stiffness", "damping", "mass"];
function Dr(t, e) {
  return e.some((n) => t[n] !== void 0);
}
function cl(t) {
  let e = {
    velocity: 0,
    stiffness: 100,
    damping: 10,
    mass: 1,
    isResolvedFromDuration: !1,
    ...t
  };
  if (!Dr(t, ll) && Dr(t, al)) {
    const n = sl(t);
    e = {
      ...e,
      ...n,
      velocity: 0,
      mass: 1
    }, e.isResolvedFromDuration = !0;
  }
  return e;
}
function xi({ keyframes: t, restDelta: e, restSpeed: n, ...r }) {
  const s = t[0], o = t[t.length - 1], i = { done: !1, value: s }, { stiffness: a, damping: l, mass: c, velocity: u, duration: f, isResolvedFromDuration: h } = cl(r), p = u ? -gt(u) : 0, m = l / (2 * Math.sqrt(a * c)), v = o - s, T = gt(Math.sqrt(a / c)), P = Math.abs(v) < 5;
  n || (n = P ? 0.01 : 2), e || (e = P ? 5e-3 : 0.5);
  let y;
  if (m < 1) {
    const x = Tn(T, m);
    y = (w) => {
      const R = Math.exp(-m * T * w);
      return o - R * ((p + m * T * v) / x * Math.sin(x * w) + v * Math.cos(x * w));
    };
  } else if (m === 1)
    y = (x) => o - Math.exp(-T * x) * (v + (p + T * v) * x);
  else {
    const x = T * Math.sqrt(m * m - 1);
    y = (w) => {
      const R = Math.exp(-m * T * w), N = Math.min(x * w, 300);
      return o - R * ((p + m * T * v) * Math.sinh(N) + x * v * Math.cosh(N)) / x;
    };
  }
  return {
    calculatedDuration: h && f || null,
    next: (x) => {
      const w = y(x);
      if (h)
        i.done = x >= f;
      else {
        let R = p;
        x !== 0 && (m < 1 ? R = vi(y, x, w) : R = 0);
        const N = Math.abs(R) <= n, k = Math.abs(o - w) <= e;
        i.done = N && k;
      }
      return i.value = i.done ? o : w, i;
    }
  };
}
function Mr({ keyframes: t, velocity: e = 0, power: n = 0.8, timeConstant: r = 325, bounceDamping: s = 10, bounceStiffness: o = 500, modifyTarget: i, min: a, max: l, restDelta: c = 0.5, restSpeed: u }) {
  const f = t[0], h = {
    done: !1,
    value: f
  }, p = (V) => a !== void 0 && V < a || l !== void 0 && V > l, m = (V) => a === void 0 ? l : l === void 0 || Math.abs(a - V) < Math.abs(l - V) ? a : l;
  let v = n * e;
  const T = f + v, P = i === void 0 ? T : i(T);
  P !== T && (v = P - f);
  const y = (V) => -v * Math.exp(-V / r), x = (V) => P + y(V), w = (V) => {
    const L = y(V), et = x(V);
    h.done = Math.abs(L) <= c, h.value = h.done ? P : et;
  };
  let R, N;
  const k = (V) => {
    p(h.value) && (R = V, N = xi({
      keyframes: [h.value, m(h.value)],
      velocity: vi(x, V, h.value),
      damping: s,
      stiffness: o,
      restDelta: c,
      restSpeed: u
    }));
  };
  return k(0), {
    calculatedDuration: null,
    next: (V) => {
      let L = !1;
      return !N && R === void 0 && (L = !0, w(V), k(V)), R !== void 0 && V > R ? N.next(V - R) : (!L && w(V), h);
    }
  };
}
const ul = (t) => {
  const e = ({ timestamp: n }) => t(n);
  return {
    start: () => I.update(e, !0),
    stop: () => yt(e),
    /**
     * If we're processing this frame we can use the
     * framelocked timestamp to keep things in sync.
     */
    now: () => Y.isProcessing ? Y.timestamp : performance.now()
  };
}, kr = 2e4;
function Lr(t) {
  let e = 0;
  const n = 50;
  let r = t.next(e);
  for (; !r.done && e < kr; )
    e += n, r = t.next(e);
  return e >= kr ? 1 / 0 : e;
}
const fl = {
  decay: Mr,
  inertia: Mr,
  tween: _e,
  keyframes: _e,
  spring: xi
};
function Ne({ autoplay: t = !0, delay: e = 0, driver: n = ul, keyframes: r, type: s = "keyframes", repeat: o = 0, repeatDelay: i = 0, repeatType: a = "loop", onPlay: l, onStop: c, onComplete: u, onUpdate: f, ...h }) {
  let p = 1, m = !1, v, T;
  const P = () => {
    T = new Promise((F) => {
      v = F;
    });
  };
  P();
  let y;
  const x = fl[s] || _e;
  let w;
  x !== _e && typeof r[0] != "number" && (w = gi([0, 100], r, {
    clamp: !1
  }), r = [0, 100]);
  const R = x({ ...h, keyframes: r });
  let N;
  a === "mirror" && (N = x({
    ...h,
    keyframes: [...r].reverse(),
    velocity: -(h.velocity || 0)
  }));
  let k = "idle", V = null, L = null, et = null;
  R.calculatedDuration === null && o && (R.calculatedDuration = Lr(R));
  const { calculatedDuration: nt } = R;
  let rt = 1 / 0, G = 1 / 0;
  nt !== null && (rt = nt + i, G = rt * (o + 1) - i);
  let O = 0;
  const B = (F) => {
    if (L === null)
      return;
    p > 0 && (L = Math.min(L, F)), p < 0 && (L = Math.min(F - G / p, L)), V !== null ? O = V : O = Math.round(F - L) * p;
    const vt = O - e * (p >= 0 ? 1 : -1), Kt = p >= 0 ? vt < 0 : vt > G;
    O = Math.max(vt, 0), k === "finished" && V === null && (O = G);
    let be = O, Pe = R;
    if (o) {
      const Vt = O / rt;
      let ut = Math.floor(Vt), ft = Vt % 1;
      !ft && Vt >= 1 && (ft = 1), ft === 1 && ut--, ut = Math.min(ut, o + 1);
      const qt = !!(ut % 2);
      qt && (a === "reverse" ? (ft = 1 - ft, i && (ft -= i / rt)) : a === "mirror" && (Pe = N));
      let Te = wt(0, 1, ft);
      O > G && (Te = a === "reverse" && qt ? 1 : 0), be = Te * rt;
    }
    const ct = Kt ? { done: !1, value: r[0] } : Pe.next(be);
    w && (ct.value = w(ct.value));
    let { done: Lt } = ct;
    !Kt && nt !== null && (Lt = p >= 0 ? O >= G : O <= 0);
    const jt = V === null && (k === "finished" || k === "running" && Lt);
    return f && f(ct.value), jt && xe(), ct;
  }, st = () => {
    y && y.stop(), y = void 0;
  }, lt = () => {
    k = "idle", st(), v(), P(), L = et = null;
  }, xe = () => {
    k = "finished", u && u(), st(), v();
  }, Yt = () => {
    if (m)
      return;
    y || (y = n(B));
    const F = y.now();
    l && l(), V !== null ? L = F - V : (!L || k === "finished") && (L = F), k === "finished" && P(), et = L, V = null, k = "running", y.start();
  };
  t && Yt();
  const Ht = {
    then(F, vt) {
      return T.then(F, vt);
    },
    get time() {
      return gt(O);
    },
    set time(F) {
      F = Tt(F), O = F, V !== null || !y || p === 0 ? V = F : L = y.now() - F / p;
    },
    get duration() {
      const F = R.calculatedDuration === null ? Lr(R) : R.calculatedDuration;
      return gt(F);
    },
    get speed() {
      return p;
    },
    set speed(F) {
      F === p || !y || (p = F, Ht.time = gt(O));
    },
    get state() {
      return k;
    },
    play: Yt,
    pause: () => {
      k = "paused", V = O;
    },
    stop: () => {
      m = !0, k !== "idle" && (k = "idle", c && c(), lt());
    },
    cancel: () => {
      et !== null && B(et), lt();
    },
    complete: () => {
      k = "finished";
    },
    sample: (F) => (L = 0, B(F))
  };
  return Ht;
}
function dl(t) {
  let e;
  return () => (e === void 0 && (e = t()), e);
}
const hl = dl(() => Object.hasOwnProperty.call(Element.prototype, "animate")), pl = /* @__PURE__ */ new Set([
  "opacity",
  "clipPath",
  "filter",
  "transform",
  "backgroundColor"
]), Re = 10, ml = 2e4, gl = (t, e) => e.type === "spring" || t === "backgroundColor" || !Xs(e.ease);
function yl(t, e, { onUpdate: n, onComplete: r, ...s }) {
  if (!(hl() && pl.has(e) && !s.repeatDelay && s.repeatType !== "mirror" && s.damping !== 0 && s.type !== "inertia"))
    return !1;
  let i = !1, a, l;
  const c = () => {
    l = new Promise((P) => {
      a = P;
    });
  };
  c();
  let { keyframes: u, duration: f = 300, ease: h, times: p } = s;
  if (gl(e, s)) {
    const P = Ne({
      ...s,
      repeat: 0,
      delay: 0
    });
    let y = { done: !1, value: u[0] };
    const x = [];
    let w = 0;
    for (; !y.done && w < ml; )
      y = P.sample(w), x.push(y.value), w += Re;
    p = void 0, u = x, f = w - Re, h = "linear";
  }
  const m = Ra(t.owner.current, e, u, {
    ...s,
    duration: f,
    /**
     * This function is currently not called if ease is provided
     * as a function so the cast is safe.
     *
     * However it would be possible for a future refinement to port
     * in easing pregeneration from Motion One for browsers that
     * support the upcoming `linear()` easing function.
     */
    ease: h,
    times: p
  }), v = () => m.cancel(), T = () => {
    I.update(v), a(), c();
  };
  return m.onfinish = () => {
    t.set(Ea(u, s)), r && r(), T();
  }, {
    then(P, y) {
      return l.then(P, y);
    },
    get timeline() {
      return m.timeline;
    },
    set timeline(P) {
      m.timeline = P, m.onfinish = null;
    },
    get time() {
      return gt(m.currentTime || 0);
    },
    set time(P) {
      m.currentTime = Tt(P);
    },
    get speed() {
      return m.playbackRate;
    },
    set speed(P) {
      m.playbackRate = P;
    },
    get duration() {
      return gt(f);
    },
    play: () => {
      i || (m.play(), yt(v));
    },
    pause: () => m.pause(),
    stop: () => {
      if (i = !0, m.playState === "idle")
        return;
      const { currentTime: P } = m;
      if (P) {
        const y = Ne({
          ...s,
          autoplay: !1
        });
        t.setWithVelocity(y.sample(P - Re).value, y.sample(P).value, Re);
      }
      T();
    },
    complete: () => m.finish(),
    cancel: T
  };
}
function vl({ keyframes: t, delay: e, onUpdate: n, onComplete: r }) {
  const s = () => (n && n(t[t.length - 1]), r && r(), {
    time: 0,
    speed: 1,
    duration: 0,
    play: $,
    pause: $,
    stop: $,
    then: (o) => (o(), Promise.resolve()),
    cancel: $,
    complete: $
  });
  return e ? Ne({
    keyframes: [0, 1],
    duration: 0,
    delay: e,
    onComplete: s
  }) : s();
}
const xl = {
  type: "spring",
  stiffness: 500,
  damping: 25,
  restSpeed: 10
}, bl = (t) => ({
  type: "spring",
  stiffness: 550,
  damping: t === 0 ? 2 * Math.sqrt(550) : 30,
  restSpeed: 10
}), Pl = {
  type: "keyframes",
  duration: 0.8
}, Tl = {
  type: "keyframes",
  ease: [0.25, 0.1, 0.35, 1],
  duration: 0.3
}, wl = (t, { keyframes: e }) => e.length > 2 ? Pl : Mt.has(t) ? t.startsWith("scale") ? bl(e[1]) : xl : Tl, wn = (t, e) => t === "zIndex" ? !1 : !!(typeof e == "number" || Array.isArray(e) || typeof e == "string" && // It's animatable if we have a string
(Ct.test(e) || e === "0") && // And it contains numbers and/or colors
!e.startsWith("url(")), Cl = /* @__PURE__ */ new Set(["brightness", "contrast", "saturate", "opacity"]);
function Sl(t) {
  const [e, n] = t.slice(0, -1).split("(");
  if (e === "drop-shadow")
    return t;
  const [r] = n.match(qe) || [];
  if (!r)
    return t;
  const s = n.replace(r, "");
  let o = Cl.has(e) ? 1 : 0;
  return r !== n && (o *= 100), e + "(" + o + s + ")";
}
const Vl = /([a-z-]*)\(.*?\)/g, Cn = {
  ...Ct,
  getAnimatableNone: (t) => {
    const e = t.match(Vl);
    return e ? e.map(Sl).join(" ") : t;
  }
}, Al = {
  ...Ls,
  // Color props
  color: K,
  backgroundColor: K,
  outlineColor: K,
  fill: K,
  stroke: K,
  // Border props
  borderColor: K,
  borderTopColor: K,
  borderRightColor: K,
  borderBottomColor: K,
  borderLeftColor: K,
  filter: Cn,
  WebkitFilter: Cn
}, Hn = (t) => Al[t];
function bi(t, e) {
  let n = Hn(t);
  return n !== Cn && (n = Ct), n.getAnimatableNone ? n.getAnimatableNone(e) : void 0;
}
const Pi = (t) => /^0[^.\s]+$/.test(t);
function Rl(t) {
  if (typeof t == "number")
    return t === 0;
  if (t !== null)
    return t === "none" || t === "0" || Pi(t);
}
function El(t, e, n, r) {
  const s = wn(e, n);
  let o;
  Array.isArray(n) ? o = [...n] : o = [null, n];
  const i = r.from !== void 0 ? r.from : t.get();
  let a;
  const l = [];
  for (let c = 0; c < o.length; c++)
    o[c] === null && (o[c] = c === 0 ? i : o[c - 1]), Rl(o[c]) && l.push(c), typeof o[c] == "string" && o[c] !== "none" && o[c] !== "0" && (a = o[c]);
  if (s && l.length && a)
    for (let c = 0; c < l.length; c++) {
      const u = l[c];
      o[u] = bi(e, a);
    }
  return o;
}
function Dl({ when: t, delay: e, delayChildren: n, staggerChildren: r, staggerDirection: s, repeat: o, repeatType: i, repeatDelay: a, from: l, elapsed: c, ...u }) {
  return !!Object.keys(u).length;
}
function Ti(t, e) {
  return t[e] || t.default || t;
}
const Kn = (t, e, n, r = {}) => (s) => {
  const o = Ti(r, t) || {}, i = o.delay || r.delay || 0;
  let { elapsed: a = 0 } = r;
  a = a - Tt(i);
  const l = El(e, t, n, o), c = l[0], u = l[l.length - 1], f = wn(t, c), h = wn(t, u);
  ye(f === h, `You are trying to animate ${t} from "${c}" to "${u}". ${c} is not an animatable value - to enable this animation set ${c} to a value animatable to ${u} via the \`style\` property.`);
  let p = {
    keyframes: l,
    velocity: e.getVelocity(),
    ease: "easeOut",
    ...o,
    delay: -a,
    onUpdate: (m) => {
      e.set(m), o.onUpdate && o.onUpdate(m);
    },
    onComplete: () => {
      s(), o.onComplete && o.onComplete();
    }
  };
  if (Dl(o) || (p = {
    ...p,
    ...wl(t, p)
  }), p.duration && (p.duration = Tt(p.duration)), p.repeatDelay && (p.repeatDelay = Tt(p.repeatDelay)), !f || !h || Aa.current || o.type === !1)
    return vl(p);
  if (e.owner && e.owner.current instanceof HTMLElement && !e.owner.getProps().onUpdate) {
    const m = yl(e, t, p);
    if (m)
      return m;
  }
  return Ne(p);
};
function Ue(t) {
  return !!(Z(t) && t.add);
}
const Ml = (t) => /^\-?\d*\.?\d+$/.test(t);
function qn(t, e) {
  t.indexOf(e) === -1 && t.push(e);
}
function Xn(t, e) {
  const n = t.indexOf(e);
  n > -1 && t.splice(n, 1);
}
class Zn {
  constructor() {
    this.subscriptions = [];
  }
  add(e) {
    return qn(this.subscriptions, e), () => Xn(this.subscriptions, e);
  }
  notify(e, n, r) {
    const s = this.subscriptions.length;
    if (s)
      if (s === 1)
        this.subscriptions[0](e, n, r);
      else
        for (let o = 0; o < s; o++) {
          const i = this.subscriptions[o];
          i && i(e, n, r);
        }
  }
  getSize() {
    return this.subscriptions.length;
  }
  clear() {
    this.subscriptions.length = 0;
  }
}
const jr = /* @__PURE__ */ new Set();
function Jn(t, e, n) {
  t || jr.has(e) || (console.warn(e), n && console.warn(n), jr.add(e));
}
const kl = (t) => !isNaN(parseFloat(t));
class Ll {
  /**
   * @param init - The initiating value
   * @param config - Optional configuration options
   *
   * -  `transformer`: A function to transform incoming values with.
   *
   * @internal
   */
  constructor(e, n = {}) {
    this.version = "10.13.1", this.timeDelta = 0, this.lastUpdated = 0, this.canTrackVelocity = !1, this.events = {}, this.updateAndNotify = (r, s = !0) => {
      this.prev = this.current, this.current = r;
      const { delta: o, timestamp: i } = Y;
      this.lastUpdated !== i && (this.timeDelta = o, this.lastUpdated = i, I.postRender(this.scheduleVelocityCheck)), this.prev !== this.current && this.events.change && this.events.change.notify(this.current), this.events.velocityChange && this.events.velocityChange.notify(this.getVelocity()), s && this.events.renderRequest && this.events.renderRequest.notify(this.current);
    }, this.scheduleVelocityCheck = () => I.postRender(this.velocityCheck), this.velocityCheck = ({ timestamp: r }) => {
      r !== this.lastUpdated && (this.prev = this.current, this.events.velocityChange && this.events.velocityChange.notify(this.getVelocity()));
    }, this.hasAnimated = !1, this.prev = this.current = e, this.canTrackVelocity = kl(this.current), this.owner = n.owner;
  }
  /**
   * Adds a function that will be notified when the `MotionValue` is updated.
   *
   * It returns a function that, when called, will cancel the subscription.
   *
   * When calling `onChange` inside a React component, it should be wrapped with the
   * `useEffect` hook. As it returns an unsubscribe function, this should be returned
   * from the `useEffect` function to ensure you don't add duplicate subscribers..
   *
   * ```jsx
   * export const MyComponent = () => {
   *   const x = useMotionValue(0)
   *   const y = useMotionValue(0)
   *   const opacity = useMotionValue(1)
   *
   *   useEffect(() => {
   *     function updateOpacity() {
   *       const maxXY = Math.max(x.get(), y.get())
   *       const newOpacity = transform(maxXY, [0, 100], [1, 0])
   *       opacity.set(newOpacity)
   *     }
   *
   *     const unsubscribeX = x.on("change", updateOpacity)
   *     const unsubscribeY = y.on("change", updateOpacity)
   *
   *     return () => {
   *       unsubscribeX()
   *       unsubscribeY()
   *     }
   *   }, [])
   *
   *   return <motion.div style={{ x }} />
   * }
   * ```
   *
   * @param subscriber - A function that receives the latest value.
   * @returns A function that, when called, will cancel this subscription.
   *
   * @deprecated
   */
  onChange(e) {
    return process.env.NODE_ENV !== "production" && Jn(!1, 'value.onChange(callback) is deprecated. Switch to value.on("change", callback).'), this.on("change", e);
  }
  on(e, n) {
    this.events[e] || (this.events[e] = new Zn());
    const r = this.events[e].add(n);
    return e === "change" ? () => {
      r(), I.read(() => {
        this.events.change.getSize() || this.stop();
      });
    } : r;
  }
  clearListeners() {
    for (const e in this.events)
      this.events[e].clear();
  }
  /**
   * Attaches a passive effect to the `MotionValue`.
   *
   * @internal
   */
  attach(e, n) {
    this.passiveEffect = e, this.stopPassiveEffect = n;
  }
  /**
   * Sets the state of the `MotionValue`.
   *
   * @remarks
   *
   * ```jsx
   * const x = useMotionValue(0)
   * x.set(10)
   * ```
   *
   * @param latest - Latest value to set.
   * @param render - Whether to notify render subscribers. Defaults to `true`
   *
   * @public
   */
  set(e, n = !0) {
    !n || !this.passiveEffect ? this.updateAndNotify(e, n) : this.passiveEffect(e, this.updateAndNotify);
  }
  setWithVelocity(e, n, r) {
    this.set(n), this.prev = e, this.timeDelta = r;
  }
  /**
   * Set the state of the `MotionValue`, stopping any active animations,
   * effects, and resets velocity to `0`.
   */
  jump(e) {
    this.updateAndNotify(e), this.prev = e, this.stop(), this.stopPassiveEffect && this.stopPassiveEffect();
  }
  /**
   * Returns the latest state of `MotionValue`
   *
   * @returns - The latest state of `MotionValue`
   *
   * @public
   */
  get() {
    return this.current;
  }
  /**
   * @public
   */
  getPrevious() {
    return this.prev;
  }
  /**
   * Returns the latest velocity of `MotionValue`
   *
   * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.
   *
   * @public
   */
  getVelocity() {
    return this.canTrackVelocity ? (
      // These casts could be avoided if parseFloat would be typed better
      yi(parseFloat(this.current) - parseFloat(this.prev), this.timeDelta)
    ) : 0;
  }
  /**
   * Registers a new animation to control this `MotionValue`. Only one
   * animation can drive a `MotionValue` at one time.
   *
   * ```jsx
   * value.start()
   * ```
   *
   * @param animation - A function that starts the provided animation
   *
   * @internal
   */
  start(e) {
    return this.stop(), new Promise((n) => {
      this.hasAnimated = !0, this.animation = e(n), this.events.animationStart && this.events.animationStart.notify();
    }).then(() => {
      this.events.animationComplete && this.events.animationComplete.notify(), this.clearAnimation();
    });
  }
  /**
   * Stop the currently active animation.
   *
   * @public
   */
  stop() {
    this.animation && (this.animation.stop(), this.events.animationCancel && this.events.animationCancel.notify()), this.clearAnimation();
  }
  /**
   * Returns `true` if this value is currently animating.
   *
   * @public
   */
  isAnimating() {
    return !!this.animation;
  }
  clearAnimation() {
    delete this.animation;
  }
  /**
   * Destroy and clean up subscribers to this `MotionValue`.
   *
   * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically
   * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually
   * created a `MotionValue` via the `motionValue` function.
   *
   * @public
   */
  destroy() {
    this.clearListeners(), this.stop(), this.stopPassiveEffect && this.stopPassiveEffect();
  }
}
function Wt(t, e) {
  return new Ll(t, e);
}
const wi = (t) => (e) => e.test(t), jl = {
  test: (t) => t === "auto",
  parse: (t) => t
}, Ci = [kt, C, at, xt, Uo, No, jl], Qt = (t) => Ci.find(wi(t)), Ol = [...Ci, K, Ct], Fl = (t) => Ol.find(wi(t));
function Bl(t, e, n) {
  t.hasValue(e) ? t.getValue(e).set(n) : t.addValue(e, Wt(n));
}
function Il(t, e) {
  const n = Ze(t, e);
  let { transitionEnd: r = {}, transition: s = {}, ...o } = n ? t.makeTargetAnimatable(n, !1) : {};
  o = { ...o, ...r };
  for (const i in o) {
    const a = ea(o[i]);
    Bl(t, i, a);
  }
}
function _l(t, e, n) {
  var r, s;
  const o = Object.keys(e).filter((a) => !t.hasValue(a)), i = o.length;
  if (i)
    for (let a = 0; a < i; a++) {
      const l = o[a], c = e[l];
      let u = null;
      Array.isArray(c) && (u = c[0]), u === null && (u = (s = (r = n[l]) !== null && r !== void 0 ? r : t.readValue(l)) !== null && s !== void 0 ? s : e[l]), u != null && (typeof u == "string" && (Ml(u) || Pi(u)) ? u = parseFloat(u) : !Fl(u) && Ct.test(c) && (u = bi(l, c)), t.addValue(l, Wt(u, { owner: t })), n[l] === void 0 && (n[l] = u), u !== null && t.setBaseTarget(l, u));
    }
}
function Nl(t, e) {
  return e ? (e[t] || e.default || e).from : void 0;
}
function Ul(t, e, n) {
  const r = {};
  for (const s in t) {
    const o = Nl(s, e);
    if (o !== void 0)
      r[s] = o;
    else {
      const i = n.getValue(s);
      i && (r[s] = i.get());
    }
  }
  return r;
}
function $l({ protectedKeys: t, needsAnimating: e }, n) {
  const r = t.hasOwnProperty(n) && e[n] !== !0;
  return e[n] = !1, r;
}
function Si(t, e, { delay: n = 0, transitionOverride: r, type: s } = {}) {
  let { transition: o = t.getDefaultTransition(), transitionEnd: i, ...a } = t.makeTargetAnimatable(e);
  const l = t.getValue("willChange");
  r && (o = r);
  const c = [], u = s && t.animationState && t.animationState.getState()[s];
  for (const f in a) {
    const h = t.getValue(f), p = a[f];
    if (!h || p === void 0 || u && $l(u, f))
      continue;
    const m = { delay: n, elapsed: 0, ...o };
    if (window.HandoffAppearAnimations && !h.hasAnimated) {
      const T = t.getProps()[Va];
      T && (m.elapsed = window.HandoffAppearAnimations(T, f, h, I));
    }
    h.start(Kn(f, h, p, t.shouldReduceMotion && Mt.has(f) ? { type: !1 } : m));
    const v = h.animation;
    Ue(l) && (l.add(f), v.then(() => l.remove(f))), c.push(v);
  }
  return i && Promise.all(c).then(() => {
    i && Il(t, i);
  }), c;
}
function Sn(t, e, n = {}) {
  const r = Ze(t, e, n.custom);
  let { transition: s = t.getDefaultTransition() || {} } = r || {};
  n.transitionOverride && (s = n.transitionOverride);
  const o = r ? () => Promise.all(Si(t, r, n)) : () => Promise.resolve(), i = t.variantChildren && t.variantChildren.size ? (l = 0) => {
    const { delayChildren: c = 0, staggerChildren: u, staggerDirection: f } = s;
    return Wl(t, e, c + l, u, f, n);
  } : () => Promise.resolve(), { when: a } = s;
  if (a) {
    const [l, c] = a === "beforeChildren" ? [o, i] : [i, o];
    return l().then(() => c());
  } else
    return Promise.all([o(), i(n.delay)]);
}
function Wl(t, e, n = 0, r = 0, s = 1, o) {
  const i = [], a = (t.variantChildren.size - 1) * r, l = s === 1 ? (c = 0) => c * r : (c = 0) => a - c * r;
  return Array.from(t.variantChildren).sort(zl).forEach((c, u) => {
    c.notify("AnimationStart", e), i.push(Sn(c, e, {
      ...o,
      delay: n + l(u)
    }).then(() => c.notify("AnimationComplete", e)));
  }), Promise.all(i);
}
function zl(t, e) {
  return t.sortNodePosition(e);
}
function Gl(t, e, n = {}) {
  t.notify("AnimationStart", e);
  let r;
  if (Array.isArray(e)) {
    const s = e.map((o) => Sn(t, o, n));
    r = Promise.all(s);
  } else if (typeof e == "string")
    r = Sn(t, e, n);
  else {
    const s = typeof e == "function" ? Ze(t, e, n.custom) : e;
    r = Promise.all(Si(t, s, n));
  }
  return r.then(() => t.notify("AnimationComplete", e));
}
const Yl = [...Ln].reverse(), Hl = Ln.length;
function Kl(t) {
  return (e) => Promise.all(e.map(({ animation: n, options: r }) => Gl(t, n, r)));
}
function ql(t) {
  let e = Kl(t);
  const n = Zl();
  let r = !0;
  const s = (l, c) => {
    const u = Ze(t, c);
    if (u) {
      const { transition: f, transitionEnd: h, ...p } = u;
      l = { ...l, ...p, ...h };
    }
    return l;
  };
  function o(l) {
    e = l(t);
  }
  function i(l, c) {
    const u = t.getProps(), f = t.getVariantContext(!0) || {}, h = [], p = /* @__PURE__ */ new Set();
    let m = {}, v = 1 / 0;
    for (let P = 0; P < Hl; P++) {
      const y = Yl[P], x = n[y], w = u[y] !== void 0 ? u[y] : f[y], R = ue(w), N = y === c ? x.isActive : null;
      N === !1 && (v = P);
      let k = w === f[y] && w !== u[y] && R;
      if (k && r && t.manuallyAnimateOnMount && (k = !1), x.protectedKeys = { ...m }, // If it isn't active and hasn't *just* been set as inactive
      !x.isActive && N === null || // If we didn't and don't have any defined prop for this animation type
      !w && !x.prevProp || // Or if the prop doesn't define an animation
      He(w) || typeof w == "boolean")
        continue;
      const V = Xl(x.prevProp, w);
      let L = V || // If we're making this variant active, we want to always make it active
      y === c && x.isActive && !k && R || // If we removed a higher-priority variant (i is in reverse order)
      P > v && R;
      const et = Array.isArray(w) ? w : [w];
      let nt = et.reduce(s, {});
      N === !1 && (nt = {});
      const { prevResolvedValues: rt = {} } = x, G = {
        ...rt,
        ...nt
      }, O = (B) => {
        L = !0, p.delete(B), x.needsAnimating[B] = !0;
      };
      for (const B in G) {
        const st = nt[B], lt = rt[B];
        m.hasOwnProperty(B) || (st !== lt ? Be(st) && Be(lt) ? !Ks(st, lt) || V ? O(B) : x.protectedKeys[B] = !0 : st !== void 0 ? O(B) : p.add(B) : st !== void 0 && p.has(B) ? O(B) : x.protectedKeys[B] = !0);
      }
      x.prevProp = w, x.prevResolvedValues = nt, x.isActive && (m = { ...m, ...nt }), r && t.blockInitialAnimation && (L = !1), L && !k && h.push(...et.map((B) => ({
        animation: B,
        options: { type: y, ...l }
      })));
    }
    if (p.size) {
      const P = {};
      p.forEach((y) => {
        const x = t.getBaseTarget(y);
        x !== void 0 && (P[y] = x);
      }), h.push({ animation: P });
    }
    let T = !!h.length;
    return r && u.initial === !1 && !t.manuallyAnimateOnMount && (T = !1), r = !1, T ? e(h) : Promise.resolve();
  }
  function a(l, c, u) {
    var f;
    if (n[l].isActive === c)
      return Promise.resolve();
    (f = t.variantChildren) === null || f === void 0 || f.forEach((p) => {
      var m;
      return (m = p.animationState) === null || m === void 0 ? void 0 : m.setActive(l, c);
    }), n[l].isActive = c;
    const h = i(u, l);
    for (const p in n)
      n[p].protectedKeys = {};
    return h;
  }
  return {
    animateChanges: i,
    setActive: a,
    setAnimateFunction: o,
    getState: () => n
  };
}
function Xl(t, e) {
  return typeof e == "string" ? e !== t : Array.isArray(e) ? !Ks(e, t) : !1;
}
function At(t = !1) {
  return {
    isActive: t,
    protectedKeys: {},
    needsAnimating: {},
    prevResolvedValues: {}
  };
}
function Zl() {
  return {
    animate: At(!0),
    whileInView: At(),
    whileHover: At(),
    whileTap: At(),
    whileDrag: At(),
    whileFocus: At(),
    exit: At()
  };
}
class Jl extends St {
  /**
   * We dynamically generate the AnimationState manager as it contains a reference
   * to the underlying animation library. We only want to load that if we load this,
   * so people can optionally code split it out using the `m` component.
   */
  constructor(e) {
    super(e), e.animationState || (e.animationState = ql(e));
  }
  updateAnimationControlsSubscription() {
    const { animate: e } = this.node.getProps();
    this.unmount(), He(e) && (this.unmount = e.subscribe(this.node));
  }
  /**
   * Subscribe any provided AnimationControls to the component's VisualElement
   */
  mount() {
    this.updateAnimationControlsSubscription();
  }
  update() {
    const { animate: e } = this.node.getProps(), { animate: n } = this.node.prevProps || {};
    e !== n && this.updateAnimationControlsSubscription();
  }
  unmount() {
  }
}
let Ql = 0;
class tc extends St {
  constructor() {
    super(...arguments), this.id = Ql++;
  }
  update() {
    if (!this.node.presenceContext)
      return;
    const { isPresent: e, onExitComplete: n, custom: r } = this.node.presenceContext, { isPresent: s } = this.node.prevPresenceContext || {};
    if (!this.node.animationState || e === s)
      return;
    const o = this.node.animationState.setActive("exit", !e, { custom: r ?? this.node.getProps().custom });
    n && !e && o.then(() => n(this.id));
  }
  mount() {
    const { register: e } = this.node.presenceContext || {};
    e && (this.unmount = e(this.id));
  }
  unmount() {
  }
}
const ec = {
  animation: {
    Feature: Jl
  },
  exit: {
    Feature: tc
  }
}, Or = (t, e) => Math.abs(t - e);
function nc(t, e) {
  const n = Or(t.x, e.x), r = Or(t.y, e.y);
  return Math.sqrt(n ** 2 + r ** 2);
}
class Vi {
  constructor(e, n, { transformPagePoint: r } = {}) {
    if (this.startEvent = null, this.lastMoveEvent = null, this.lastMoveEventInfo = null, this.handlers = {}, this.updatePoint = () => {
      if (!(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const c = hn(this.lastMoveEventInfo, this.history), u = this.startEvent !== null, f = nc(c.offset, { x: 0, y: 0 }) >= 3;
      if (!u && !f)
        return;
      const { point: h } = c, { timestamp: p } = Y;
      this.history.push({ ...h, timestamp: p });
      const { onStart: m, onMove: v } = this.handlers;
      u || (m && m(this.lastMoveEvent, c), this.startEvent = this.lastMoveEvent), v && v(this.lastMoveEvent, c);
    }, this.handlePointerMove = (c, u) => {
      this.lastMoveEvent = c, this.lastMoveEventInfo = dn(u, this.transformPagePoint), I.update(this.updatePoint, !0);
    }, this.handlePointerUp = (c, u) => {
      if (this.end(), !(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const { onEnd: f, onSessionEnd: h } = this.handlers, p = hn(c.type === "pointercancel" ? this.lastMoveEventInfo : dn(u, this.transformPagePoint), this.history);
      this.startEvent && f && f(c, p), h && h(c, p);
    }, !Ws(e))
      return;
    this.handlers = n, this.transformPagePoint = r;
    const s = Xe(e), o = dn(s, this.transformPagePoint), { point: i } = o, { timestamp: a } = Y;
    this.history = [{ ...i, timestamp: a }];
    const { onSessionStart: l } = n;
    l && l(e, hn(o, this.history)), this.removeListeners = Pt(mt(window, "pointermove", this.handlePointerMove), mt(window, "pointerup", this.handlePointerUp), mt(window, "pointercancel", this.handlePointerUp));
  }
  updateHandlers(e) {
    this.handlers = e;
  }
  end() {
    this.removeListeners && this.removeListeners(), yt(this.updatePoint);
  }
}
function dn(t, e) {
  return e ? { point: e(t.point) } : t;
}
function Fr(t, e) {
  return { x: t.x - e.x, y: t.y - e.y };
}
function hn({ point: t }, e) {
  return {
    point: t,
    delta: Fr(t, Ai(e)),
    offset: Fr(t, rc(e)),
    velocity: sc(e, 0.1)
  };
}
function rc(t) {
  return t[0];
}
function Ai(t) {
  return t[t.length - 1];
}
function sc(t, e) {
  if (t.length < 2)
    return { x: 0, y: 0 };
  let n = t.length - 1, r = null;
  const s = Ai(t);
  for (; n >= 0 && (r = t[n], !(s.timestamp - r.timestamp > Tt(e))); )
    n--;
  if (!r)
    return { x: 0, y: 0 };
  const o = gt(s.timestamp - r.timestamp);
  if (o === 0)
    return { x: 0, y: 0 };
  const i = {
    x: (s.x - r.x) / o,
    y: (s.y - r.y) / o
  };
  return i.x === 1 / 0 && (i.x = 0), i.y === 1 / 0 && (i.y = 0), i;
}
function J(t) {
  return t.max - t.min;
}
function Vn(t, e = 0, n = 0.01) {
  return Math.abs(t - e) <= n;
}
function Br(t, e, n, r = 0.5) {
  t.origin = r, t.originPoint = _(e.min, e.max, t.origin), t.scale = J(n) / J(e), (Vn(t.scale, 1, 1e-4) || isNaN(t.scale)) && (t.scale = 1), t.translate = _(n.min, n.max, t.origin) - t.originPoint, (Vn(t.translate) || isNaN(t.translate)) && (t.translate = 0);
}
function oe(t, e, n, r) {
  Br(t.x, e.x, n.x, r ? r.originX : void 0), Br(t.y, e.y, n.y, r ? r.originY : void 0);
}
function Ir(t, e, n) {
  t.min = n.min + e.min, t.max = t.min + J(e);
}
function ic(t, e, n) {
  Ir(t.x, e.x, n.x), Ir(t.y, e.y, n.y);
}
function _r(t, e, n) {
  t.min = e.min - n.min, t.max = t.min + J(e);
}
function ae(t, e, n) {
  _r(t.x, e.x, n.x), _r(t.y, e.y, n.y);
}
function oc(t, { min: e, max: n }, r) {
  return e !== void 0 && t < e ? t = r ? _(e, t, r.min) : Math.max(t, e) : n !== void 0 && t > n && (t = r ? _(n, t, r.max) : Math.min(t, n)), t;
}
function Nr(t, e, n) {
  return {
    min: e !== void 0 ? t.min + e : void 0,
    max: n !== void 0 ? t.max + n - (t.max - t.min) : void 0
  };
}
function ac(t, { top: e, left: n, bottom: r, right: s }) {
  return {
    x: Nr(t.x, n, s),
    y: Nr(t.y, e, r)
  };
}
function Ur(t, e) {
  let n = e.min - t.min, r = e.max - t.max;
  return e.max - e.min < t.max - t.min && ([n, r] = [r, n]), { min: n, max: r };
}
function lc(t, e) {
  return {
    x: Ur(t.x, e.x),
    y: Ur(t.y, e.y)
  };
}
function cc(t, e) {
  let n = 0.5;
  const r = J(t), s = J(e);
  return s > r ? n = de(e.min, e.max - r, t.min) : r > s && (n = de(t.min, t.max - s, e.min)), wt(0, 1, n);
}
function uc(t, e) {
  const n = {};
  return e.min !== void 0 && (n.min = e.min - t.min), e.max !== void 0 && (n.max = e.max - t.min), n;
}
const An = 0.35;
function fc(t = An) {
  return t === !1 ? t = 0 : t === !0 && (t = An), {
    x: $r(t, "left", "right"),
    y: $r(t, "top", "bottom")
  };
}
function $r(t, e, n) {
  return {
    min: Wr(t, e),
    max: Wr(t, n)
  };
}
function Wr(t, e) {
  return typeof t == "number" ? t : t[e] || 0;
}
const zr = () => ({
  translate: 0,
  scale: 1,
  origin: 0,
  originPoint: 0
}), Nt = () => ({
  x: zr(),
  y: zr()
}), Gr = () => ({ min: 0, max: 0 }), z = () => ({
  x: Gr(),
  y: Gr()
});
function ot(t) {
  return [t("x"), t("y")];
}
function Ri({ top: t, left: e, right: n, bottom: r }) {
  return {
    x: { min: e, max: n },
    y: { min: t, max: r }
  };
}
function dc({ x: t, y: e }) {
  return { top: e.min, right: t.max, bottom: e.max, left: t.min };
}
function hc(t, e) {
  if (!e)
    return t;
  const n = e({ x: t.left, y: t.top }), r = e({ x: t.right, y: t.bottom });
  return {
    top: n.y,
    left: n.x,
    bottom: r.y,
    right: r.x
  };
}
function pn(t) {
  return t === void 0 || t === 1;
}
function Rn({ scale: t, scaleX: e, scaleY: n }) {
  return !pn(t) || !pn(e) || !pn(n);
}
function Rt(t) {
  return Rn(t) || Ei(t) || t.z || t.rotate || t.rotateX || t.rotateY;
}
function Ei(t) {
  return Yr(t.x) || Yr(t.y);
}
function Yr(t) {
  return t && t !== "0%";
}
function $e(t, e, n) {
  const r = t - n, s = e * r;
  return n + s;
}
function Hr(t, e, n, r, s) {
  return s !== void 0 && (t = $e(t, s, r)), $e(t, n, r) + e;
}
function En(t, e = 0, n = 1, r, s) {
  t.min = Hr(t.min, e, n, r, s), t.max = Hr(t.max, e, n, r, s);
}
function Di(t, { x: e, y: n }) {
  En(t.x, e.translate, e.scale, e.originPoint), En(t.y, n.translate, n.scale, n.originPoint);
}
function pc(t, e, n, r = !1) {
  const s = n.length;
  if (!s)
    return;
  e.x = e.y = 1;
  let o, i;
  for (let a = 0; a < s; a++) {
    o = n[a], i = o.projectionDelta;
    const l = o.instance;
    l && l.style && l.style.display === "contents" || (r && o.options.layoutScroll && o.scroll && o !== o.root && Ut(t, {
      x: -o.scroll.offset.x,
      y: -o.scroll.offset.y
    }), i && (e.x *= i.x.scale, e.y *= i.y.scale, Di(t, i)), r && Rt(o.latestValues) && Ut(t, o.latestValues));
  }
  e.x = Kr(e.x), e.y = Kr(e.y);
}
function Kr(t) {
  return Number.isInteger(t) || t > 1.0000000000001 || t < 0.999999999999 ? t : 1;
}
function bt(t, e) {
  t.min = t.min + e, t.max = t.max + e;
}
function qr(t, e, [n, r, s]) {
  const o = e[s] !== void 0 ? e[s] : 0.5, i = _(t.min, t.max, o);
  En(t, e[n], e[r], i, e.scale);
}
const mc = ["x", "scaleX", "originX"], gc = ["y", "scaleY", "originY"];
function Ut(t, e) {
  qr(t.x, e, mc), qr(t.y, e, gc);
}
function Mi(t, e) {
  return Ri(hc(t.getBoundingClientRect(), e));
}
function yc(t, e, n) {
  const r = Mi(t, n), { scroll: s } = e;
  return s && (bt(r.x, s.offset.x), bt(r.y, s.offset.y)), r;
}
const vc = /* @__PURE__ */ new WeakMap();
class xc {
  constructor(e) {
    this.openGlobalLock = null, this.isDragging = !1, this.currentDirection = null, this.originPoint = { x: 0, y: 0 }, this.constraints = !1, this.hasMutatedConstraints = !1, this.elastic = z(), this.visualElement = e;
  }
  start(e, { snapToCursor: n = !1 } = {}) {
    const { presenceContext: r } = this.visualElement;
    if (r && r.isPresent === !1)
      return;
    const s = (l) => {
      this.stopAnimation(), n && this.snapToCursor(Xe(l, "page").point);
    }, o = (l, c) => {
      const { drag: u, dragPropagation: f, onDragStart: h } = this.getProps();
      if (u && !f && (this.openGlobalLock && this.openGlobalLock(), this.openGlobalLock = Gs(u), !this.openGlobalLock))
        return;
      this.isDragging = !0, this.currentDirection = null, this.resolveConstraints(), this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0, this.visualElement.projection.target = void 0), ot((m) => {
        let v = this.getAxisMotionValue(m).get() || 0;
        if (at.test(v)) {
          const { projection: T } = this.visualElement;
          if (T && T.layout) {
            const P = T.layout.layoutBox[m];
            P && (v = J(P) * (parseFloat(v) / 100));
          }
        }
        this.originPoint[m] = v;
      }), h && I.update(() => h(l, c), !1, !0);
      const { animationState: p } = this.visualElement;
      p && p.setActive("whileDrag", !0);
    }, i = (l, c) => {
      const { dragPropagation: u, dragDirectionLock: f, onDirectionLock: h, onDrag: p } = this.getProps();
      if (!u && !this.openGlobalLock)
        return;
      const { offset: m } = c;
      if (f && this.currentDirection === null) {
        this.currentDirection = bc(m), this.currentDirection !== null && h && h(this.currentDirection);
        return;
      }
      this.updateAxis("x", c.point, m), this.updateAxis("y", c.point, m), this.visualElement.render(), p && p(l, c);
    }, a = (l, c) => this.stop(l, c);
    this.panSession = new Vi(e, {
      onSessionStart: s,
      onStart: o,
      onMove: i,
      onSessionEnd: a
    }, { transformPagePoint: this.visualElement.getTransformPagePoint() });
  }
  stop(e, n) {
    const r = this.isDragging;
    if (this.cancel(), !r)
      return;
    const { velocity: s } = n;
    this.startAnimation(s);
    const { onDragEnd: o } = this.getProps();
    o && I.update(() => o(e, n));
  }
  cancel() {
    this.isDragging = !1;
    const { projection: e, animationState: n } = this.visualElement;
    e && (e.isAnimationBlocked = !1), this.panSession && this.panSession.end(), this.panSession = void 0;
    const { dragPropagation: r } = this.getProps();
    !r && this.openGlobalLock && (this.openGlobalLock(), this.openGlobalLock = null), n && n.setActive("whileDrag", !1);
  }
  updateAxis(e, n, r) {
    const { drag: s } = this.getProps();
    if (!r || !Ee(e, s, this.currentDirection))
      return;
    const o = this.getAxisMotionValue(e);
    let i = this.originPoint[e] + r[e];
    this.constraints && this.constraints[e] && (i = oc(i, this.constraints[e], this.elastic[e])), o.set(i);
  }
  resolveConstraints() {
    const { dragConstraints: e, dragElastic: n } = this.getProps(), { layout: r } = this.visualElement.projection || {}, s = this.constraints;
    e && It(e) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : e && r ? this.constraints = ac(r.layoutBox, e) : this.constraints = !1, this.elastic = fc(n), s !== this.constraints && r && this.constraints && !this.hasMutatedConstraints && ot((o) => {
      this.getAxisMotionValue(o) && (this.constraints[o] = uc(r.layoutBox[o], this.constraints[o]));
    });
  }
  resolveRefConstraints() {
    const { dragConstraints: e, onMeasureDragConstraints: n } = this.getProps();
    if (!e || !It(e))
      return !1;
    const r = e.current;
    it(r !== null, "If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.");
    const { projection: s } = this.visualElement;
    if (!s || !s.layout)
      return !1;
    const o = yc(r, s.root, this.visualElement.getTransformPagePoint());
    let i = lc(s.layout.layoutBox, o);
    if (n) {
      const a = n(dc(i));
      this.hasMutatedConstraints = !!a, a && (i = Ri(a));
    }
    return i;
  }
  startAnimation(e) {
    const { drag: n, dragMomentum: r, dragElastic: s, dragTransition: o, dragSnapToOrigin: i, onDragTransitionEnd: a } = this.getProps(), l = this.constraints || {}, c = ot((u) => {
      if (!Ee(u, n, this.currentDirection))
        return;
      let f = l && l[u] || {};
      i && (f = { min: 0, max: 0 });
      const h = s ? 200 : 1e6, p = s ? 40 : 1e7, m = {
        type: "inertia",
        velocity: r ? e[u] : 0,
        bounceStiffness: h,
        bounceDamping: p,
        timeConstant: 750,
        restDelta: 1,
        restSpeed: 10,
        ...o,
        ...f
      };
      return this.startAxisValueAnimation(u, m);
    });
    return Promise.all(c).then(a);
  }
  startAxisValueAnimation(e, n) {
    const r = this.getAxisMotionValue(e);
    return r.start(Kn(e, r, 0, n));
  }
  stopAnimation() {
    ot((e) => this.getAxisMotionValue(e).stop());
  }
  /**
   * Drag works differently depending on which props are provided.
   *
   * - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.
   * - Otherwise, we apply the delta to the x/y motion values.
   */
  getAxisMotionValue(e) {
    const n = "_drag" + e.toUpperCase(), r = this.visualElement.getProps(), s = r[n];
    return s || this.visualElement.getValue(e, (r.initial ? r.initial[e] : void 0) || 0);
  }
  snapToCursor(e) {
    ot((n) => {
      const { drag: r } = this.getProps();
      if (!Ee(n, r, this.currentDirection))
        return;
      const { projection: s } = this.visualElement, o = this.getAxisMotionValue(n);
      if (s && s.layout) {
        const { min: i, max: a } = s.layout.layoutBox[n];
        o.set(e[n] - _(i, a, 0.5));
      }
    });
  }
  /**
   * When the viewport resizes we want to check if the measured constraints
   * have changed and, if so, reposition the element within those new constraints
   * relative to where it was before the resize.
   */
  scalePositionWithinConstraints() {
    if (!this.visualElement.current)
      return;
    const { drag: e, dragConstraints: n } = this.getProps(), { projection: r } = this.visualElement;
    if (!It(n) || !r || !this.constraints)
      return;
    this.stopAnimation();
    const s = { x: 0, y: 0 };
    ot((i) => {
      const a = this.getAxisMotionValue(i);
      if (a) {
        const l = a.get();
        s[i] = cc({ min: l, max: l }, this.constraints[i]);
      }
    });
    const { transformTemplate: o } = this.visualElement.getProps();
    this.visualElement.current.style.transform = o ? o({}, "") : "none", r.root && r.root.updateScroll(), r.updateLayout(), this.resolveConstraints(), ot((i) => {
      if (!Ee(i, e, null))
        return;
      const a = this.getAxisMotionValue(i), { min: l, max: c } = this.constraints[i];
      a.set(_(l, c, s[i]));
    });
  }
  addListeners() {
    if (!this.visualElement.current)
      return;
    vc.set(this.visualElement, this);
    const e = this.visualElement.current, n = mt(e, "pointerdown", (l) => {
      const { drag: c, dragListener: u = !0 } = this.getProps();
      c && u && this.start(l);
    }), r = () => {
      const { dragConstraints: l } = this.getProps();
      It(l) && (this.constraints = this.resolveRefConstraints());
    }, { projection: s } = this.visualElement, o = s.addEventListener("measure", r);
    s && !s.layout && (s.root && s.root.updateScroll(), s.updateLayout()), r();
    const i = pt(window, "resize", () => this.scalePositionWithinConstraints()), a = s.addEventListener("didUpdate", ({ delta: l, hasLayoutChanged: c }) => {
      this.isDragging && c && (ot((u) => {
        const f = this.getAxisMotionValue(u);
        f && (this.originPoint[u] += l[u].translate, f.set(f.get() + l[u].translate));
      }), this.visualElement.render());
    });
    return () => {
      i(), n(), o(), a && a();
    };
  }
  getProps() {
    const e = this.visualElement.getProps(), { drag: n = !1, dragDirectionLock: r = !1, dragPropagation: s = !1, dragConstraints: o = !1, dragElastic: i = An, dragMomentum: a = !0 } = e;
    return {
      ...e,
      drag: n,
      dragDirectionLock: r,
      dragPropagation: s,
      dragConstraints: o,
      dragElastic: i,
      dragMomentum: a
    };
  }
}
function Ee(t, e, n) {
  return (e === !0 || e === t) && (n === null || n === t);
}
function bc(t, e = 10) {
  let n = null;
  return Math.abs(t.y) > e ? n = "y" : Math.abs(t.x) > e && (n = "x"), n;
}
class Pc extends St {
  constructor(e) {
    super(e), this.removeGroupControls = $, this.removeListeners = $, this.controls = new xc(e);
  }
  mount() {
    const { dragControls: e } = this.node.getProps();
    e && (this.removeGroupControls = e.subscribe(this.controls)), this.removeListeners = this.controls.addListeners() || $;
  }
  unmount() {
    this.removeGroupControls(), this.removeListeners();
  }
}
const Xr = (t) => (e, n) => {
  t && I.update(() => t(e, n));
};
class Tc extends St {
  constructor() {
    super(...arguments), this.removePointerDownListener = $;
  }
  onPointerDown(e) {
    this.session = new Vi(e, this.createPanHandlers(), { transformPagePoint: this.node.getTransformPagePoint() });
  }
  createPanHandlers() {
    const { onPanSessionStart: e, onPanStart: n, onPan: r, onPanEnd: s } = this.node.getProps();
    return {
      onSessionStart: Xr(e),
      onStart: Xr(n),
      onMove: r,
      onEnd: (o, i) => {
        delete this.session, s && I.update(() => s(o, i));
      }
    };
  }
  mount() {
    this.removePointerDownListener = mt(this.node.current, "pointerdown", (e) => this.onPointerDown(e));
  }
  update() {
    this.session && this.session.updateHandlers(this.createPanHandlers());
  }
  unmount() {
    this.removePointerDownListener(), this.session && this.session.end();
  }
}
function wc() {
  const t = X(Ge);
  if (t === null)
    return [!0, null];
  const { isPresent: e, onExitComplete: n, register: r } = t, s = kn();
  return le(() => r(s), []), !e && n ? [!1, () => n && n(s)] : [!0];
}
const Le = {
  /**
   * Global flag as to whether the tree has animated since the last time
   * we resized the window
   */
  hasAnimatedSinceResize: !0,
  /**
   * We set this to true once, on the first update. Any nodes added to the tree beyond that
   * update will be given a `data-projection-id` attribute.
   */
  hasEverUpdated: !1
};
function Zr(t, e) {
  return e.max === e.min ? 0 : t / (e.max - e.min) * 100;
}
const te = {
  correct: (t, e) => {
    if (!e.target)
      return t;
    if (typeof t == "string")
      if (C.test(t))
        t = parseFloat(t);
      else
        return t;
    const n = Zr(t, e.target.x), r = Zr(t, e.target.y);
    return `${n}% ${r}%`;
  }
}, Cc = {
  correct: (t, { treeScale: e, projectionDelta: n }) => {
    const r = t, s = Ct.parse(t);
    if (s.length > 5)
      return r;
    const o = Ct.createTransformer(t), i = typeof s[0] != "number" ? 1 : 0, a = n.x.scale * e.x, l = n.y.scale * e.y;
    s[0 + i] /= a, s[1 + i] /= l;
    const c = _(a, l, 0.5);
    return typeof s[2 + i] == "number" && (s[2 + i] /= c), typeof s[3 + i] == "number" && (s[3 + i] /= c), o(s);
  }
};
class Sc extends We.Component {
  /**
   * This only mounts projection nodes for components that
   * need measuring, we might want to do it for all components
   * in order to incorporate transforms
   */
  componentDidMount() {
    const { visualElement: e, layoutGroup: n, switchLayoutGroup: r, layoutId: s } = this.props, { projection: o } = e;
    Lo(Vc), o && (n.group && n.group.add(o), r && r.register && s && r.register(o), o.root.didUpdate(), o.addEventListener("animationComplete", () => {
      this.safeToRemove();
    }), o.setOptions({
      ...o.options,
      onExitComplete: () => this.safeToRemove()
    })), Le.hasEverUpdated = !0;
  }
  getSnapshotBeforeUpdate(e) {
    const { layoutDependency: n, visualElement: r, drag: s, isPresent: o } = this.props, i = r.projection;
    return i && (i.isPresent = o, s || e.layoutDependency !== n || n === void 0 ? i.willUpdate() : this.safeToRemove(), e.isPresent !== o && (o ? i.promote() : i.relegate() || I.postRender(() => {
      const a = i.getStack();
      (!a || !a.members.length) && this.safeToRemove();
    }))), null;
  }
  componentDidUpdate() {
    const { projection: e } = this.props.visualElement;
    e && (e.root.didUpdate(), queueMicrotask(() => {
      !e.currentAnimation && e.isLead() && this.safeToRemove();
    }));
  }
  componentWillUnmount() {
    const { visualElement: e, layoutGroup: n, switchLayoutGroup: r } = this.props, { projection: s } = e;
    s && (s.scheduleCheckAfterUnmount(), n && n.group && n.group.remove(s), r && r.deregister && r.deregister(s));
  }
  safeToRemove() {
    const { safeToRemove: e } = this.props;
    e && e();
  }
  render() {
    return null;
  }
}
function ki(t) {
  const [e, n] = wc(), r = X(On);
  return We.createElement(Sc, { ...t, layoutGroup: r, switchLayoutGroup: X(Rs), isPresent: e, safeToRemove: n });
}
const Vc = {
  borderRadius: {
    ...te,
    applyTo: [
      "borderTopLeftRadius",
      "borderTopRightRadius",
      "borderBottomLeftRadius",
      "borderBottomRightRadius"
    ]
  },
  borderTopLeftRadius: te,
  borderTopRightRadius: te,
  borderBottomLeftRadius: te,
  borderBottomRightRadius: te,
  boxShadow: Cc
}, Li = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"], Ac = Li.length, Jr = (t) => typeof t == "string" ? parseFloat(t) : t, Qr = (t) => typeof t == "number" || C.test(t);
function Rc(t, e, n, r, s, o) {
  s ? (t.opacity = _(
    0,
    // TODO Reinstate this if only child
    n.opacity !== void 0 ? n.opacity : 1,
    Ec(r)
  ), t.opacityExit = _(e.opacity !== void 0 ? e.opacity : 1, 0, Dc(r))) : o && (t.opacity = _(e.opacity !== void 0 ? e.opacity : 1, n.opacity !== void 0 ? n.opacity : 1, r));
  for (let i = 0; i < Ac; i++) {
    const a = `border${Li[i]}Radius`;
    let l = ts(e, a), c = ts(n, a);
    if (l === void 0 && c === void 0)
      continue;
    l || (l = 0), c || (c = 0), l === 0 || c === 0 || Qr(l) === Qr(c) ? (t[a] = Math.max(_(Jr(l), Jr(c), r), 0), (at.test(c) || at.test(l)) && (t[a] += "%")) : t[a] = c;
  }
  (e.rotate || n.rotate) && (t.rotate = _(e.rotate || 0, n.rotate || 0, r));
}
function ts(t, e) {
  return t[e] !== void 0 ? t[e] : t.borderRadius;
}
const Ec = ji(0, 0.5, zn), Dc = ji(0.5, 0.95, $);
function ji(t, e, n) {
  return (r) => r < t ? 0 : r > e ? 1 : n(de(t, e, r));
}
function es(t, e) {
  t.min = e.min, t.max = e.max;
}
function tt(t, e) {
  es(t.x, e.x), es(t.y, e.y);
}
function ns(t, e, n, r, s) {
  return t -= e, t = $e(t, 1 / n, r), s !== void 0 && (t = $e(t, 1 / s, r)), t;
}
function Mc(t, e = 0, n = 1, r = 0.5, s, o = t, i = t) {
  if (at.test(e) && (e = parseFloat(e), e = _(i.min, i.max, e / 100) - i.min), typeof e != "number")
    return;
  let a = _(o.min, o.max, r);
  t === o && (a -= e), t.min = ns(t.min, e, n, a, s), t.max = ns(t.max, e, n, a, s);
}
function rs(t, e, [n, r, s], o, i) {
  Mc(t, e[n], e[r], e[s], e.scale, o, i);
}
const kc = ["x", "scaleX", "originX"], Lc = ["y", "scaleY", "originY"];
function ss(t, e, n, r) {
  rs(t.x, e, kc, n ? n.x : void 0, r ? r.x : void 0), rs(t.y, e, Lc, n ? n.y : void 0, r ? r.y : void 0);
}
function is(t) {
  return t.translate === 0 && t.scale === 1;
}
function Oi(t) {
  return is(t.x) && is(t.y);
}
function jc(t, e) {
  return t.x.min === e.x.min && t.x.max === e.x.max && t.y.min === e.y.min && t.y.max === e.y.max;
}
function Fi(t, e) {
  return Math.round(t.x.min) === Math.round(e.x.min) && Math.round(t.x.max) === Math.round(e.x.max) && Math.round(t.y.min) === Math.round(e.y.min) && Math.round(t.y.max) === Math.round(e.y.max);
}
function os(t) {
  return J(t.x) / J(t.y);
}
class Oc {
  constructor() {
    this.members = [];
  }
  add(e) {
    qn(this.members, e), e.scheduleRender();
  }
  remove(e) {
    if (Xn(this.members, e), e === this.prevLead && (this.prevLead = void 0), e === this.lead) {
      const n = this.members[this.members.length - 1];
      n && this.promote(n);
    }
  }
  relegate(e) {
    const n = this.members.findIndex((s) => e === s);
    if (n === 0)
      return !1;
    let r;
    for (let s = n; s >= 0; s--) {
      const o = this.members[s];
      if (o.isPresent !== !1) {
        r = o;
        break;
      }
    }
    return r ? (this.promote(r), !0) : !1;
  }
  promote(e, n) {
    const r = this.lead;
    if (e !== r && (this.prevLead = r, this.lead = e, e.show(), r)) {
      r.instance && r.scheduleRender(), e.scheduleRender(), e.resumeFrom = r, n && (e.resumeFrom.preserveOpacity = !0), r.snapshot && (e.snapshot = r.snapshot, e.snapshot.latestValues = r.animationValues || r.latestValues), e.root && e.root.isUpdating && (e.isLayoutDirty = !0);
      const { crossfade: s } = e.options;
      s === !1 && r.hide();
    }
  }
  exitAnimationComplete() {
    this.members.forEach((e) => {
      const { options: n, resumingFrom: r } = e;
      n.onExitComplete && n.onExitComplete(), r && r.options.onExitComplete && r.options.onExitComplete();
    });
  }
  scheduleRender() {
    this.members.forEach((e) => {
      e.instance && e.scheduleRender(!1);
    });
  }
  /**
   * Clear any leads that have been removed this render to prevent them from being
   * used in future animations and to prevent memory leaks
   */
  removeLeadSnapshot() {
    this.lead && this.lead.snapshot && (this.lead.snapshot = void 0);
  }
}
function as(t, e, n) {
  let r = "";
  const s = t.x.translate / e.x, o = t.y.translate / e.y;
  if ((s || o) && (r = `translate3d(${s}px, ${o}px, 0) `), (e.x !== 1 || e.y !== 1) && (r += `scale(${1 / e.x}, ${1 / e.y}) `), n) {
    const { rotate: l, rotateX: c, rotateY: u } = n;
    l && (r += `rotate(${l}deg) `), c && (r += `rotateX(${c}deg) `), u && (r += `rotateY(${u}deg) `);
  }
  const i = t.x.scale * e.x, a = t.y.scale * e.y;
  return (i !== 1 || a !== 1) && (r += `scale(${i}, ${a})`), r || "none";
}
const Fc = (t, e) => t.depth - e.depth;
class Bc {
  constructor() {
    this.children = [], this.isDirty = !1;
  }
  add(e) {
    qn(this.children, e), this.isDirty = !0;
  }
  remove(e) {
    Xn(this.children, e), this.isDirty = !0;
  }
  forEach(e) {
    this.isDirty && this.children.sort(Fc), this.isDirty = !1, this.children.forEach(e);
  }
}
function Ic(t, e) {
  const n = performance.now(), r = ({ timestamp: s }) => {
    const o = s - n;
    o >= e && (yt(r), t(o - e));
  };
  return I.read(r, !0), () => yt(r);
}
function _c(t) {
  window.MotionDebug && window.MotionDebug.record(t);
}
function Nc(t) {
  return t instanceof SVGElement && t.tagName !== "svg";
}
function Uc(t, e, n) {
  const r = Z(t) ? t : Wt(t);
  return r.start(Kn("", r, e, n)), r.animation;
}
const ls = ["", "X", "Y", "Z"], cs = 1e3;
let $c = 0;
const Et = {
  type: "projectionFrame",
  totalNodes: 0,
  resolvedTargetDeltas: 0,
  recalculatedProjection: 0
};
function Bi({ attachResizeListener: t, defaultParent: e, measureScroll: n, checkIsScrollRoot: r, resetTransform: s }) {
  return class {
    constructor(i = {}, a = e == null ? void 0 : e()) {
      this.id = $c++, this.animationId = 0, this.children = /* @__PURE__ */ new Set(), this.options = {}, this.isTreeAnimating = !1, this.isAnimationBlocked = !1, this.isLayoutDirty = !1, this.isProjectionDirty = !1, this.isSharedProjectionDirty = !1, this.isTransformDirty = !1, this.updateManuallyBlocked = !1, this.updateBlockedByResize = !1, this.isUpdating = !1, this.isSVG = !1, this.needsReset = !1, this.shouldResetTransform = !1, this.treeScale = { x: 1, y: 1 }, this.eventHandlers = /* @__PURE__ */ new Map(), this.hasTreeAnimated = !1, this.updateScheduled = !1, this.checkUpdateFailed = () => {
        this.isUpdating && (this.isUpdating = !1, this.clearAllSnapshots());
      }, this.updateProjection = () => {
        Et.totalNodes = Et.resolvedTargetDeltas = Et.recalculatedProjection = 0, this.nodes.forEach(Gc), this.nodes.forEach(Xc), this.nodes.forEach(Zc), this.nodes.forEach(Yc), _c(Et);
      }, this.hasProjected = !1, this.isVisible = !0, this.animationProgress = 0, this.sharedNodes = /* @__PURE__ */ new Map(), this.latestValues = i, this.root = a ? a.root || a : this, this.path = a ? [...a.path, a] : [], this.parent = a, this.depth = a ? a.depth + 1 : 0;
      for (let l = 0; l < this.path.length; l++)
        this.path[l].shouldResetTransform = !0;
      this.root === this && (this.nodes = new Bc());
    }
    addEventListener(i, a) {
      return this.eventHandlers.has(i) || this.eventHandlers.set(i, new Zn()), this.eventHandlers.get(i).add(a);
    }
    notifyListeners(i, ...a) {
      const l = this.eventHandlers.get(i);
      l && l.notify(...a);
    }
    hasListeners(i) {
      return this.eventHandlers.has(i);
    }
    /**
     * Lifecycles
     */
    mount(i, a = this.root.hasTreeAnimated) {
      if (this.instance)
        return;
      this.isSVG = Nc(i), this.instance = i;
      const { layoutId: l, layout: c, visualElement: u } = this.options;
      if (u && !u.current && u.mount(i), this.root.nodes.add(this), this.parent && this.parent.children.add(this), a && (c || l) && (this.isLayoutDirty = !0), t) {
        let f;
        const h = () => this.root.updateBlockedByResize = !1;
        t(i, () => {
          this.root.updateBlockedByResize = !0, f && f(), f = Ic(h, 250), Le.hasAnimatedSinceResize && (Le.hasAnimatedSinceResize = !1, this.nodes.forEach(fs));
        });
      }
      l && this.root.registerSharedNode(l, this), this.options.animate !== !1 && u && (l || c) && this.addEventListener("didUpdate", ({ delta: f, hasLayoutChanged: h, hasRelativeTargetChanged: p, layout: m }) => {
        if (this.isTreeAnimationBlocked()) {
          this.target = void 0, this.relativeTarget = void 0;
          return;
        }
        const v = this.options.transition || u.getDefaultTransition() || nu, { onLayoutAnimationStart: T, onLayoutAnimationComplete: P } = u.getProps(), y = !this.targetLayout || !Fi(this.targetLayout, m) || p, x = !h && p;
        if (this.options.layoutRoot || this.resumeFrom && this.resumeFrom.instance || x || h && (y || !this.currentAnimation)) {
          this.resumeFrom && (this.resumingFrom = this.resumeFrom, this.resumingFrom.resumingFrom = void 0), this.setAnimationOrigin(f, x);
          const w = {
            ...Ti(v, "layout"),
            onPlay: T,
            onComplete: P
          };
          (u.shouldReduceMotion || this.options.layoutRoot) && (w.delay = 0, w.type = !1), this.startAnimation(w);
        } else
          h || fs(this), this.isLead() && this.options.onExitComplete && this.options.onExitComplete();
        this.targetLayout = m;
      });
    }
    unmount() {
      this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this);
      const i = this.getStack();
      i && i.remove(this), this.parent && this.parent.children.delete(this), this.instance = void 0, yt(this.updateProjection);
    }
    // only on the root
    blockUpdate() {
      this.updateManuallyBlocked = !0;
    }
    unblockUpdate() {
      this.updateManuallyBlocked = !1;
    }
    isUpdateBlocked() {
      return this.updateManuallyBlocked || this.updateBlockedByResize;
    }
    isTreeAnimationBlocked() {
      return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || !1;
    }
    // Note: currently only running on root node
    startUpdate() {
      this.isUpdateBlocked() || (this.isUpdating = !0, this.nodes && this.nodes.forEach(Jc), this.animationId++);
    }
    getTransformTemplate() {
      const { visualElement: i } = this.options;
      return i && i.getProps().transformTemplate;
    }
    willUpdate(i = !0) {
      if (this.root.hasTreeAnimated = !0, this.root.isUpdateBlocked()) {
        this.options.onExitComplete && this.options.onExitComplete();
        return;
      }
      if (!this.root.isUpdating && this.root.startUpdate(), this.isLayoutDirty)
        return;
      this.isLayoutDirty = !0;
      for (let u = 0; u < this.path.length; u++) {
        const f = this.path[u];
        f.shouldResetTransform = !0, f.updateScroll("snapshot"), f.options.layoutRoot && f.willUpdate(!1);
      }
      const { layoutId: a, layout: l } = this.options;
      if (a === void 0 && !l)
        return;
      const c = this.getTransformTemplate();
      this.prevTransformTemplateValue = c ? c(this.latestValues, "") : void 0, this.updateSnapshot(), i && this.notifyListeners("willUpdate");
    }
    update() {
      if (this.updateScheduled = !1, this.isUpdateBlocked()) {
        this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(us);
        return;
      }
      this.isUpdating || this.nodes.forEach(Kc), this.isUpdating = !1, this.nodes.forEach(qc), this.nodes.forEach(Wc), this.nodes.forEach(zc), this.clearAllSnapshots();
      const a = performance.now();
      Y.delta = wt(0, 1e3 / 60, a - Y.timestamp), Y.timestamp = a, Y.isProcessing = !0, rn.update.process(Y), rn.preRender.process(Y), rn.render.process(Y), Y.isProcessing = !1;
    }
    didUpdate() {
      this.updateScheduled || (this.updateScheduled = !0, queueMicrotask(() => this.update()));
    }
    clearAllSnapshots() {
      this.nodes.forEach(Hc), this.sharedNodes.forEach(Qc);
    }
    scheduleUpdateProjection() {
      I.preRender(this.updateProjection, !1, !0);
    }
    scheduleCheckAfterUnmount() {
      I.postRender(() => {
        this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed();
      });
    }
    /**
     * Update measurements
     */
    updateSnapshot() {
      this.snapshot || !this.instance || (this.snapshot = this.measure());
    }
    updateLayout() {
      if (!this.instance || (this.updateScroll(), !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty))
        return;
      if (this.resumeFrom && !this.resumeFrom.instance)
        for (let l = 0; l < this.path.length; l++)
          this.path[l].updateScroll();
      const i = this.layout;
      this.layout = this.measure(!1), this.layoutCorrected = z(), this.isLayoutDirty = !1, this.projectionDelta = void 0, this.notifyListeners("measure", this.layout.layoutBox);
      const { visualElement: a } = this.options;
      a && a.notify("LayoutMeasure", this.layout.layoutBox, i ? i.layoutBox : void 0);
    }
    updateScroll(i = "measure") {
      let a = !!(this.options.layoutScroll && this.instance);
      this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === i && (a = !1), a && (this.scroll = {
        animationId: this.root.animationId,
        phase: i,
        isRoot: r(this.instance),
        offset: n(this.instance)
      });
    }
    resetTransform() {
      if (!s)
        return;
      const i = this.isLayoutDirty || this.shouldResetTransform, a = this.projectionDelta && !Oi(this.projectionDelta), l = this.getTransformTemplate(), c = l ? l(this.latestValues, "") : void 0, u = c !== this.prevTransformTemplateValue;
      i && (a || Rt(this.latestValues) || u) && (s(this.instance, c), this.shouldResetTransform = !1, this.scheduleRender());
    }
    measure(i = !0) {
      const a = this.measurePageBox();
      let l = this.removeElementScroll(a);
      return i && (l = this.removeTransform(l)), ru(l), {
        animationId: this.root.animationId,
        measuredBox: a,
        layoutBox: l,
        latestValues: {},
        source: this.id
      };
    }
    measurePageBox() {
      const { visualElement: i } = this.options;
      if (!i)
        return z();
      const a = i.measureViewportBox(), { scroll: l } = this.root;
      return l && (bt(a.x, l.offset.x), bt(a.y, l.offset.y)), a;
    }
    removeElementScroll(i) {
      const a = z();
      tt(a, i);
      for (let l = 0; l < this.path.length; l++) {
        const c = this.path[l], { scroll: u, options: f } = c;
        if (c !== this.root && u && f.layoutScroll) {
          if (u.isRoot) {
            tt(a, i);
            const { scroll: h } = this.root;
            h && (bt(a.x, -h.offset.x), bt(a.y, -h.offset.y));
          }
          bt(a.x, u.offset.x), bt(a.y, u.offset.y);
        }
      }
      return a;
    }
    applyTransform(i, a = !1) {
      const l = z();
      tt(l, i);
      for (let c = 0; c < this.path.length; c++) {
        const u = this.path[c];
        !a && u.options.layoutScroll && u.scroll && u !== u.root && Ut(l, {
          x: -u.scroll.offset.x,
          y: -u.scroll.offset.y
        }), Rt(u.latestValues) && Ut(l, u.latestValues);
      }
      return Rt(this.latestValues) && Ut(l, this.latestValues), l;
    }
    removeTransform(i) {
      const a = z();
      tt(a, i);
      for (let l = 0; l < this.path.length; l++) {
        const c = this.path[l];
        if (!c.instance || !Rt(c.latestValues))
          continue;
        Rn(c.latestValues) && c.updateSnapshot();
        const u = z(), f = c.measurePageBox();
        tt(u, f), ss(a, c.latestValues, c.snapshot ? c.snapshot.layoutBox : void 0, u);
      }
      return Rt(this.latestValues) && ss(a, this.latestValues), a;
    }
    setTargetDelta(i) {
      this.targetDelta = i, this.root.scheduleUpdateProjection(), this.isProjectionDirty = !0;
    }
    setOptions(i) {
      this.options = {
        ...this.options,
        ...i,
        crossfade: i.crossfade !== void 0 ? i.crossfade : !0
      };
    }
    clearMeasurements() {
      this.scroll = void 0, this.layout = void 0, this.snapshot = void 0, this.prevTransformTemplateValue = void 0, this.targetDelta = void 0, this.target = void 0, this.isLayoutDirty = !1;
    }
    forceRelativeParentToResolveTarget() {
      this.relativeParent && this.relativeParent.resolvedRelativeTargetAt !== Y.timestamp && this.relativeParent.resolveTargetDelta(!0);
    }
    resolveTargetDelta(i = !1) {
      var a;
      const l = this.getLead();
      this.isProjectionDirty || (this.isProjectionDirty = l.isProjectionDirty), this.isTransformDirty || (this.isTransformDirty = l.isTransformDirty), this.isSharedProjectionDirty || (this.isSharedProjectionDirty = l.isSharedProjectionDirty);
      const c = !!this.resumingFrom || this !== l;
      if (!(i || c && this.isSharedProjectionDirty || this.isProjectionDirty || !((a = this.parent) === null || a === void 0) && a.isProjectionDirty || this.attemptToResolveRelativeTarget))
        return;
      const { layout: f, layoutId: h } = this.options;
      if (!(!this.layout || !(f || h))) {
        if (this.resolvedRelativeTargetAt = Y.timestamp, !this.targetDelta && !this.relativeTarget) {
          const p = this.getClosestProjectingParent();
          p && p.layout && this.animationProgress !== 1 ? (this.relativeParent = p, this.forceRelativeParentToResolveTarget(), this.relativeTarget = z(), this.relativeTargetOrigin = z(), ae(this.relativeTargetOrigin, this.layout.layoutBox, p.layout.layoutBox), tt(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0;
        }
        if (!(!this.relativeTarget && !this.targetDelta)) {
          if (this.target || (this.target = z(), this.targetWithTransforms = z()), this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target ? (this.forceRelativeParentToResolveTarget(), ic(this.target, this.relativeTarget, this.relativeParent.target)) : this.targetDelta ? (this.resumingFrom ? this.target = this.applyTransform(this.layout.layoutBox) : tt(this.target, this.layout.layoutBox), Di(this.target, this.targetDelta)) : tt(this.target, this.layout.layoutBox), this.attemptToResolveRelativeTarget) {
            this.attemptToResolveRelativeTarget = !1;
            const p = this.getClosestProjectingParent();
            p && !!p.resumingFrom == !!this.resumingFrom && !p.options.layoutScroll && p.target && this.animationProgress !== 1 ? (this.relativeParent = p, this.forceRelativeParentToResolveTarget(), this.relativeTarget = z(), this.relativeTargetOrigin = z(), ae(this.relativeTargetOrigin, this.target, p.target), tt(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0;
          }
          Et.resolvedTargetDeltas++;
        }
      }
    }
    getClosestProjectingParent() {
      if (!(!this.parent || Rn(this.parent.latestValues) || Ei(this.parent.latestValues)))
        return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent();
    }
    isProjecting() {
      return !!((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout);
    }
    calcProjection() {
      var i;
      const a = this.getLead(), l = !!this.resumingFrom || this !== a;
      let c = !0;
      if ((this.isProjectionDirty || !((i = this.parent) === null || i === void 0) && i.isProjectionDirty) && (c = !1), l && (this.isSharedProjectionDirty || this.isTransformDirty) && (c = !1), this.resolvedRelativeTargetAt === Y.timestamp && (c = !1), c)
        return;
      const { layout: u, layoutId: f } = this.options;
      if (this.isTreeAnimating = !!(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation), this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0), !this.layout || !(u || f))
        return;
      tt(this.layoutCorrected, this.layout.layoutBox);
      const h = this.treeScale.x, p = this.treeScale.y;
      pc(this.layoutCorrected, this.treeScale, this.path, l), a.layout && !a.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1) && (a.target = a.layout.layoutBox);
      const { target: m } = a;
      if (!m) {
        this.projectionTransform && (this.projectionDelta = Nt(), this.projectionTransform = "none", this.scheduleRender());
        return;
      }
      this.projectionDelta || (this.projectionDelta = Nt(), this.projectionDeltaWithTransform = Nt());
      const v = this.projectionTransform;
      oe(this.projectionDelta, this.layoutCorrected, m, this.latestValues), this.projectionTransform = as(this.projectionDelta, this.treeScale), (this.projectionTransform !== v || this.treeScale.x !== h || this.treeScale.y !== p) && (this.hasProjected = !0, this.scheduleRender(), this.notifyListeners("projectionUpdate", m)), Et.recalculatedProjection++;
    }
    hide() {
      this.isVisible = !1;
    }
    show() {
      this.isVisible = !0;
    }
    scheduleRender(i = !0) {
      if (this.options.scheduleRender && this.options.scheduleRender(), i) {
        const a = this.getStack();
        a && a.scheduleRender();
      }
      this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0);
    }
    setAnimationOrigin(i, a = !1) {
      const l = this.snapshot, c = l ? l.latestValues : {}, u = { ...this.latestValues }, f = Nt();
      (!this.relativeParent || !this.relativeParent.options.layoutRoot) && (this.relativeTarget = this.relativeTargetOrigin = void 0), this.attemptToResolveRelativeTarget = !a;
      const h = z(), p = l ? l.source : void 0, m = this.layout ? this.layout.source : void 0, v = p !== m, T = this.getStack(), P = !T || T.members.length <= 1, y = !!(v && !P && this.options.crossfade === !0 && !this.path.some(eu));
      this.animationProgress = 0;
      let x;
      this.mixTargetDelta = (w) => {
        const R = w / 1e3;
        ds(f.x, i.x, R), ds(f.y, i.y, R), this.setTargetDelta(f), this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout && (ae(h, this.layout.layoutBox, this.relativeParent.layout.layoutBox), tu(this.relativeTarget, this.relativeTargetOrigin, h, R), x && jc(this.relativeTarget, x) && (this.isProjectionDirty = !1), x || (x = z()), tt(x, this.relativeTarget)), v && (this.animationValues = u, Rc(u, c, this.latestValues, R, y, P)), this.root.scheduleUpdateProjection(), this.scheduleRender(), this.animationProgress = R;
      }, this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0);
    }
    startAnimation(i) {
      this.notifyListeners("animationStart"), this.currentAnimation && this.currentAnimation.stop(), this.resumingFrom && this.resumingFrom.currentAnimation && this.resumingFrom.currentAnimation.stop(), this.pendingAnimation && (yt(this.pendingAnimation), this.pendingAnimation = void 0), this.pendingAnimation = I.update(() => {
        Le.hasAnimatedSinceResize = !0, this.currentAnimation = Uc(0, cs, {
          ...i,
          onUpdate: (a) => {
            this.mixTargetDelta(a), i.onUpdate && i.onUpdate(a);
          },
          onComplete: () => {
            i.onComplete && i.onComplete(), this.completeAnimation();
          }
        }), this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation), this.pendingAnimation = void 0;
      });
    }
    completeAnimation() {
      this.resumingFrom && (this.resumingFrom.currentAnimation = void 0, this.resumingFrom.preserveOpacity = void 0);
      const i = this.getStack();
      i && i.exitAnimationComplete(), this.resumingFrom = this.currentAnimation = this.animationValues = void 0, this.notifyListeners("animationComplete");
    }
    finishAnimation() {
      this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(cs), this.currentAnimation.stop()), this.completeAnimation();
    }
    applyTransformsToTarget() {
      const i = this.getLead();
      let { targetWithTransforms: a, target: l, layout: c, latestValues: u } = i;
      if (!(!a || !l || !c)) {
        if (this !== i && this.layout && c && Ii(this.options.animationType, this.layout.layoutBox, c.layoutBox)) {
          l = this.target || z();
          const f = J(this.layout.layoutBox.x);
          l.x.min = i.target.x.min, l.x.max = l.x.min + f;
          const h = J(this.layout.layoutBox.y);
          l.y.min = i.target.y.min, l.y.max = l.y.min + h;
        }
        tt(a, l), Ut(a, u), oe(this.projectionDeltaWithTransform, this.layoutCorrected, a, u);
      }
    }
    registerSharedNode(i, a) {
      this.sharedNodes.has(i) || this.sharedNodes.set(i, new Oc()), this.sharedNodes.get(i).add(a);
      const c = a.options.initialPromotionConfig;
      a.promote({
        transition: c ? c.transition : void 0,
        preserveFollowOpacity: c && c.shouldPreserveFollowOpacity ? c.shouldPreserveFollowOpacity(a) : void 0
      });
    }
    isLead() {
      const i = this.getStack();
      return i ? i.lead === this : !0;
    }
    getLead() {
      var i;
      const { layoutId: a } = this.options;
      return a ? ((i = this.getStack()) === null || i === void 0 ? void 0 : i.lead) || this : this;
    }
    getPrevLead() {
      var i;
      const { layoutId: a } = this.options;
      return a ? (i = this.getStack()) === null || i === void 0 ? void 0 : i.prevLead : void 0;
    }
    getStack() {
      const { layoutId: i } = this.options;
      if (i)
        return this.root.sharedNodes.get(i);
    }
    promote({ needsReset: i, transition: a, preserveFollowOpacity: l } = {}) {
      const c = this.getStack();
      c && c.promote(this, l), i && (this.projectionDelta = void 0, this.needsReset = !0), a && this.setOptions({ transition: a });
    }
    relegate() {
      const i = this.getStack();
      return i ? i.relegate(this) : !1;
    }
    resetRotation() {
      const { visualElement: i } = this.options;
      if (!i)
        return;
      let a = !1;
      const { latestValues: l } = i;
      if ((l.rotate || l.rotateX || l.rotateY || l.rotateZ) && (a = !0), !a)
        return;
      const c = {};
      for (let u = 0; u < ls.length; u++) {
        const f = "rotate" + ls[u];
        l[f] && (c[f] = l[f], i.setStaticValue(f, 0));
      }
      i.render();
      for (const u in c)
        i.setStaticValue(u, c[u]);
      i.scheduleRender();
    }
    getProjectionStyles(i = {}) {
      var a, l;
      const c = {};
      if (!this.instance || this.isSVG)
        return c;
      if (this.isVisible)
        c.visibility = "";
      else
        return { visibility: "hidden" };
      const u = this.getTransformTemplate();
      if (this.needsReset)
        return this.needsReset = !1, c.opacity = "", c.pointerEvents = ke(i.pointerEvents) || "", c.transform = u ? u(this.latestValues, "") : "none", c;
      const f = this.getLead();
      if (!this.projectionDelta || !this.layout || !f.target) {
        const v = {};
        return this.options.layoutId && (v.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1, v.pointerEvents = ke(i.pointerEvents) || ""), this.hasProjected && !Rt(this.latestValues) && (v.transform = u ? u({}, "") : "none", this.hasProjected = !1), v;
      }
      const h = f.animationValues || f.latestValues;
      this.applyTransformsToTarget(), c.transform = as(this.projectionDeltaWithTransform, this.treeScale, h), u && (c.transform = u(h, c.transform));
      const { x: p, y: m } = this.projectionDelta;
      c.transformOrigin = `${p.origin * 100}% ${m.origin * 100}% 0`, f.animationValues ? c.opacity = f === this ? (l = (a = h.opacity) !== null && a !== void 0 ? a : this.latestValues.opacity) !== null && l !== void 0 ? l : 1 : this.preserveOpacity ? this.latestValues.opacity : h.opacityExit : c.opacity = f === this ? h.opacity !== void 0 ? h.opacity : "" : h.opacityExit !== void 0 ? h.opacityExit : 0;
      for (const v in Oe) {
        if (h[v] === void 0)
          continue;
        const { correct: T, applyTo: P } = Oe[v], y = c.transform === "none" ? h[v] : T(h[v], f);
        if (P) {
          const x = P.length;
          for (let w = 0; w < x; w++)
            c[P[w]] = y;
        } else
          c[v] = y;
      }
      return this.options.layoutId && (c.pointerEvents = f === this ? ke(i.pointerEvents) || "" : "none"), c;
    }
    clearSnapshot() {
      this.resumeFrom = this.snapshot = void 0;
    }
    // Only run on root
    resetTree() {
      this.root.nodes.forEach((i) => {
        var a;
        return (a = i.currentAnimation) === null || a === void 0 ? void 0 : a.stop();
      }), this.root.nodes.forEach(us), this.root.sharedNodes.clear();
    }
  };
}
function Wc(t) {
  t.updateLayout();
}
function zc(t) {
  var e;
  const n = ((e = t.resumeFrom) === null || e === void 0 ? void 0 : e.snapshot) || t.snapshot;
  if (t.isLead() && t.layout && n && t.hasListeners("didUpdate")) {
    const { layoutBox: r, measuredBox: s } = t.layout, { animationType: o } = t.options, i = n.source !== t.layout.source;
    o === "size" ? ot((f) => {
      const h = i ? n.measuredBox[f] : n.layoutBox[f], p = J(h);
      h.min = r[f].min, h.max = h.min + p;
    }) : Ii(o, n.layoutBox, r) && ot((f) => {
      const h = i ? n.measuredBox[f] : n.layoutBox[f], p = J(r[f]);
      h.max = h.min + p, t.relativeTarget && !t.currentAnimation && (t.isProjectionDirty = !0, t.relativeTarget[f].max = t.relativeTarget[f].min + p);
    });
    const a = Nt();
    oe(a, r, n.layoutBox);
    const l = Nt();
    i ? oe(l, t.applyTransform(s, !0), n.measuredBox) : oe(l, r, n.layoutBox);
    const c = !Oi(a);
    let u = !1;
    if (!t.resumeFrom) {
      const f = t.getClosestProjectingParent();
      if (f && !f.resumeFrom) {
        const { snapshot: h, layout: p } = f;
        if (h && p) {
          const m = z();
          ae(m, n.layoutBox, h.layoutBox);
          const v = z();
          ae(v, r, p.layoutBox), Fi(m, v) || (u = !0), f.options.layoutRoot && (t.relativeTarget = v, t.relativeTargetOrigin = m, t.relativeParent = f);
        }
      }
    }
    t.notifyListeners("didUpdate", {
      layout: r,
      snapshot: n,
      delta: l,
      layoutDelta: a,
      hasLayoutChanged: c,
      hasRelativeTargetChanged: u
    });
  } else if (t.isLead()) {
    const { onExitComplete: r } = t.options;
    r && r();
  }
  t.options.transition = void 0;
}
function Gc(t) {
  Et.totalNodes++, t.parent && (t.isProjecting() || (t.isProjectionDirty = t.parent.isProjectionDirty), t.isSharedProjectionDirty || (t.isSharedProjectionDirty = !!(t.isProjectionDirty || t.parent.isProjectionDirty || t.parent.isSharedProjectionDirty)), t.isTransformDirty || (t.isTransformDirty = t.parent.isTransformDirty));
}
function Yc(t) {
  t.isProjectionDirty = t.isSharedProjectionDirty = t.isTransformDirty = !1;
}
function Hc(t) {
  t.clearSnapshot();
}
function us(t) {
  t.clearMeasurements();
}
function Kc(t) {
  t.isLayoutDirty = !1;
}
function qc(t) {
  const { visualElement: e } = t.options;
  e && e.getProps().onBeforeLayoutMeasure && e.notify("BeforeLayoutMeasure"), t.resetTransform();
}
function fs(t) {
  t.finishAnimation(), t.targetDelta = t.relativeTarget = t.target = void 0, t.isProjectionDirty = !0;
}
function Xc(t) {
  t.resolveTargetDelta();
}
function Zc(t) {
  t.calcProjection();
}
function Jc(t) {
  t.resetRotation();
}
function Qc(t) {
  t.removeLeadSnapshot();
}
function ds(t, e, n) {
  t.translate = _(e.translate, 0, n), t.scale = _(e.scale, 1, n), t.origin = e.origin, t.originPoint = e.originPoint;
}
function hs(t, e, n, r) {
  t.min = _(e.min, n.min, r), t.max = _(e.max, n.max, r);
}
function tu(t, e, n, r) {
  hs(t.x, e.x, n.x, r), hs(t.y, e.y, n.y, r);
}
function eu(t) {
  return t.animationValues && t.animationValues.opacityExit !== void 0;
}
const nu = {
  duration: 0.45,
  ease: [0.4, 0, 0.1, 1]
}, ps = (t) => typeof navigator < "u" && navigator.userAgent.toLowerCase().includes(t), ms = ps("applewebkit/") && !ps("chrome/") ? Math.round : $;
function gs(t) {
  t.min = ms(t.min), t.max = ms(t.max);
}
function ru(t) {
  gs(t.x), gs(t.y);
}
function Ii(t, e, n) {
  return t === "position" || t === "preserve-aspect" && !Vn(os(e), os(n), 0.2);
}
const su = Bi({
  attachResizeListener: (t, e) => pt(t, "resize", e),
  measureScroll: () => ({
    x: document.documentElement.scrollLeft || document.body.scrollLeft,
    y: document.documentElement.scrollTop || document.body.scrollTop
  }),
  checkIsScrollRoot: () => !0
}), mn = {
  current: void 0
}, _i = Bi({
  measureScroll: (t) => ({
    x: t.scrollLeft,
    y: t.scrollTop
  }),
  defaultParent: () => {
    if (!mn.current) {
      const t = new su({});
      t.mount(window), t.setOptions({ layoutScroll: !0 }), mn.current = t;
    }
    return mn.current;
  },
  resetTransform: (t, e) => {
    t.style.transform = e !== void 0 ? e : "none";
  },
  checkIsScrollRoot: (t) => window.getComputedStyle(t).position === "fixed"
}), iu = {
  pan: {
    Feature: Tc
  },
  drag: {
    Feature: Pc,
    ProjectionNode: _i,
    MeasureLayout: ki
  }
}, ou = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/;
function au(t) {
  const e = ou.exec(t);
  if (!e)
    return [,];
  const [, n, r] = e;
  return [n, r];
}
const lu = 4;
function Dn(t, e, n = 1) {
  it(n <= lu, `Max CSS variable fallback depth detected in property "${t}". This may indicate a circular fallback dependency.`);
  const [r, s] = au(t);
  if (!r)
    return;
  const o = window.getComputedStyle(e).getPropertyValue(r);
  return o ? o.trim() : xn(s) ? Dn(s, e, n + 1) : s;
}
function cu(t, { ...e }, n) {
  const r = t.current;
  if (!(r instanceof Element))
    return { target: e, transitionEnd: n };
  n && (n = { ...n }), t.values.forEach((s) => {
    const o = s.get();
    if (!xn(o))
      return;
    const i = Dn(o, r);
    i && s.set(i);
  });
  for (const s in e) {
    const o = e[s];
    if (!xn(o))
      continue;
    const i = Dn(o, r);
    i && (e[s] = i, n || (n = {}), n[s] === void 0 && (n[s] = o));
  }
  return { target: e, transitionEnd: n };
}
const uu = /* @__PURE__ */ new Set([
  "width",
  "height",
  "top",
  "left",
  "right",
  "bottom",
  "x",
  "y",
  "translateX",
  "translateY"
]), Ni = (t) => uu.has(t), fu = (t) => Object.keys(t).some(Ni), De = (t) => t === kt || t === C, ys = (t, e) => parseFloat(t.split(", ")[e]), vs = (t, e) => (n, { transform: r }) => {
  if (r === "none" || !r)
    return 0;
  const s = r.match(/^matrix3d\((.+)\)$/);
  if (s)
    return ys(s[1], e);
  {
    const o = r.match(/^matrix\((.+)\)$/);
    return o ? ys(o[1], t) : 0;
  }
}, du = /* @__PURE__ */ new Set(["x", "y", "z"]), hu = pe.filter((t) => !du.has(t));
function pu(t) {
  const e = [];
  return hu.forEach((n) => {
    const r = t.getValue(n);
    r !== void 0 && (e.push([n, r.get()]), r.set(n.startsWith("scale") ? 1 : 0));
  }), e.length && t.render(), e;
}
const zt = {
  // Dimensions
  width: ({ x: t }, { paddingLeft: e = "0", paddingRight: n = "0" }) => t.max - t.min - parseFloat(e) - parseFloat(n),
  height: ({ y: t }, { paddingTop: e = "0", paddingBottom: n = "0" }) => t.max - t.min - parseFloat(e) - parseFloat(n),
  top: (t, { top: e }) => parseFloat(e),
  left: (t, { left: e }) => parseFloat(e),
  bottom: ({ y: t }, { top: e }) => parseFloat(e) + (t.max - t.min),
  right: ({ x: t }, { left: e }) => parseFloat(e) + (t.max - t.min),
  // Transform
  x: vs(4, 13),
  y: vs(5, 14)
};
zt.translateX = zt.x;
zt.translateY = zt.y;
const mu = (t, e, n) => {
  const r = e.measureViewportBox(), s = e.current, o = getComputedStyle(s), { display: i } = o, a = {};
  i === "none" && e.setStaticValue("display", t.display || "block"), n.forEach((c) => {
    a[c] = zt[c](r, o);
  }), e.render();
  const l = e.measureViewportBox();
  return n.forEach((c) => {
    const u = e.getValue(c);
    u && u.jump(a[c]), t[c] = zt[c](l, o);
  }), t;
}, gu = (t, e, n = {}, r = {}) => {
  e = { ...e }, r = { ...r };
  const s = Object.keys(e).filter(Ni);
  let o = [], i = !1;
  const a = [];
  if (s.forEach((l) => {
    const c = t.getValue(l);
    if (!t.hasValue(l))
      return;
    let u = n[l], f = Qt(u);
    const h = e[l];
    let p;
    if (Be(h)) {
      const m = h.length, v = h[0] === null ? 1 : 0;
      u = h[v], f = Qt(u);
      for (let T = v; T < m && h[T] !== null; T++)
        p ? it(Qt(h[T]) === p, "All keyframes must be of the same type") : (p = Qt(h[T]), it(p === f || De(f) && De(p), "Keyframes must be of the same dimension as the current value"));
    } else
      p = Qt(h);
    if (f !== p)
      if (De(f) && De(p)) {
        const m = c.get();
        typeof m == "string" && c.set(parseFloat(m)), typeof h == "string" ? e[l] = parseFloat(h) : Array.isArray(h) && p === C && (e[l] = h.map(parseFloat));
      } else
        f != null && f.transform && (p != null && p.transform) && (u === 0 || h === 0) ? u === 0 ? c.set(p.transform(u)) : e[l] = f.transform(h) : (i || (o = pu(t), i = !0), a.push(l), r[l] = r[l] !== void 0 ? r[l] : e[l], c.jump(h));
  }), a.length) {
    const l = a.indexOf("height") >= 0 ? window.pageYOffset : null, c = mu(e, t, a);
    return o.length && o.forEach(([u, f]) => {
      t.getValue(u).set(f);
    }), t.render(), Ye && l !== null && window.scrollTo({ top: l }), { target: c, transitionEnd: r };
  } else
    return { target: e, transitionEnd: r };
};
function yu(t, e, n, r) {
  return fu(e) ? gu(t, e, n, r) : { target: e, transitionEnd: r };
}
const vu = (t, e, n, r) => {
  const s = cu(t, e, r);
  return e = s.target, r = s.transitionEnd, yu(t, e, n, r);
}, Mn = { current: null }, Ui = { current: !1 };
function xu() {
  if (Ui.current = !0, !!Ye)
    if (window.matchMedia) {
      const t = window.matchMedia("(prefers-reduced-motion)"), e = () => Mn.current = t.matches;
      t.addListener(e), e();
    } else
      Mn.current = !1;
}
function bu(t, e, n) {
  const { willChange: r } = e;
  for (const s in e) {
    const o = e[s], i = n[s];
    if (Z(o))
      t.addValue(s, o), Ue(r) && r.add(s), process.env.NODE_ENV === "development" && Jn(o.version === "10.13.1", `Attempting to mix Framer Motion versions ${o.version} with 10.13.1 may not work as expected.`);
    else if (Z(i))
      t.addValue(s, Wt(o, { owner: t })), Ue(r) && r.remove(s);
    else if (i !== o)
      if (t.hasValue(s)) {
        const a = t.getValue(s);
        !a.hasAnimated && a.set(o);
      } else {
        const a = t.getStaticValue(s);
        t.addValue(s, Wt(a !== void 0 ? a : o, { owner: t }));
      }
  }
  for (const s in n)
    e[s] === void 0 && t.removeValue(s);
  return e;
}
const xs = /* @__PURE__ */ new WeakMap(), $i = Object.keys(fe), Pu = $i.length, bs = [
  "AnimationStart",
  "AnimationComplete",
  "Update",
  "BeforeLayoutMeasure",
  "LayoutMeasure",
  "LayoutAnimationStart",
  "LayoutAnimationComplete"
], Tu = jn.length;
class wu {
  constructor({ parent: e, props: n, presenceContext: r, reducedMotionConfig: s, visualState: o }, i = {}) {
    this.current = null, this.children = /* @__PURE__ */ new Set(), this.isVariantNode = !1, this.isControllingVariants = !1, this.shouldReduceMotion = null, this.values = /* @__PURE__ */ new Map(), this.features = {}, this.valueSubscriptions = /* @__PURE__ */ new Map(), this.prevMotionValues = {}, this.events = {}, this.propEventSubscriptions = {}, this.notifyUpdate = () => this.notify("Update", this.latestValues), this.render = () => {
      this.current && (this.triggerBuild(), this.renderInstance(this.current, this.renderState, this.props.style, this.projection));
    }, this.scheduleRender = () => I.render(this.render, !1, !0);
    const { latestValues: a, renderState: l } = o;
    this.latestValues = a, this.baseTarget = { ...a }, this.initialValues = n.initial ? { ...a } : {}, this.renderState = l, this.parent = e, this.props = n, this.presenceContext = r, this.depth = e ? e.depth + 1 : 0, this.reducedMotionConfig = s, this.options = i, this.isControllingVariants = Ke(n), this.isVariantNode = As(n), this.isVariantNode && (this.variantChildren = /* @__PURE__ */ new Set()), this.manuallyAnimateOnMount = !!(e && e.current);
    const { willChange: c, ...u } = this.scrapeMotionValuesFromProps(n, {});
    for (const f in u) {
      const h = u[f];
      a[f] !== void 0 && Z(h) && (h.set(a[f], !1), Ue(c) && c.add(f));
    }
  }
  /**
   * This method takes React props and returns found MotionValues. For example, HTML
   * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.
   *
   * This isn't an abstract method as it needs calling in the constructor, but it is
   * intended to be one.
   */
  scrapeMotionValuesFromProps(e, n) {
    return {};
  }
  mount(e) {
    this.current = e, xs.set(e, this), this.projection && !this.projection.instance && this.projection.mount(e), this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)), this.values.forEach((n, r) => this.bindToMotionValue(r, n)), Ui.current || xu(), this.shouldReduceMotion = this.reducedMotionConfig === "never" ? !1 : this.reducedMotionConfig === "always" ? !0 : Mn.current, process.env.NODE_ENV !== "production" && Jn(this.shouldReduceMotion !== !0, "You have Reduced Motion enabled on your device. Animations may not appear as expected."), this.parent && this.parent.children.add(this), this.update(this.props, this.presenceContext);
  }
  unmount() {
    xs.delete(this.current), this.projection && this.projection.unmount(), yt(this.notifyUpdate), yt(this.render), this.valueSubscriptions.forEach((e) => e()), this.removeFromVariantTree && this.removeFromVariantTree(), this.parent && this.parent.children.delete(this);
    for (const e in this.events)
      this.events[e].clear();
    for (const e in this.features)
      this.features[e].unmount();
    this.current = null;
  }
  bindToMotionValue(e, n) {
    const r = Mt.has(e), s = n.on("change", (i) => {
      this.latestValues[e] = i, this.props.onUpdate && I.update(this.notifyUpdate, !1, !0), r && this.projection && (this.projection.isTransformDirty = !0);
    }), o = n.on("renderRequest", this.scheduleRender);
    this.valueSubscriptions.set(e, () => {
      s(), o();
    });
  }
  sortNodePosition(e) {
    return !this.current || !this.sortInstanceNodePosition || this.type !== e.type ? 0 : this.sortInstanceNodePosition(this.current, e.current);
  }
  loadFeatures({ children: e, ...n }, r, s, o) {
    let i, a;
    if (process.env.NODE_ENV !== "production" && s && r) {
      const l = "You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.";
      n.ignoreStrict ? ye(!1, l) : it(!1, l);
    }
    for (let l = 0; l < Pu; l++) {
      const c = $i[l], { isEnabled: u, Feature: f, ProjectionNode: h, MeasureLayout: p } = fe[c];
      h && (i = h), u(n) && (!this.features[c] && f && (this.features[c] = new f(this)), p && (a = p));
    }
    if (!this.projection && i) {
      this.projection = new i(this.latestValues, this.parent && this.parent.projection);
      const { layoutId: l, layout: c, drag: u, dragConstraints: f, layoutScroll: h, layoutRoot: p } = n;
      this.projection.setOptions({
        layoutId: l,
        layout: c,
        alwaysMeasureLayout: !!u || f && It(f),
        visualElement: this,
        scheduleRender: () => this.scheduleRender(),
        /**
         * TODO: Update options in an effect. This could be tricky as it'll be too late
         * to update by the time layout animations run.
         * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,
         * ensuring it gets called if there's no potential layout animations.
         *
         */
        animationType: typeof c == "string" ? c : "both",
        initialPromotionConfig: o,
        layoutScroll: h,
        layoutRoot: p
      });
    }
    return a;
  }
  updateFeatures() {
    for (const e in this.features) {
      const n = this.features[e];
      n.isMounted ? n.update() : (n.mount(), n.isMounted = !0);
    }
  }
  triggerBuild() {
    this.build(this.renderState, this.latestValues, this.options, this.props);
  }
  /**
   * Measure the current viewport box with or without transforms.
   * Only measures axis-aligned boxes, rotate and skew must be manually
   * removed with a re-render to work.
   */
  measureViewportBox() {
    return this.current ? this.measureInstanceViewportBox(this.current, this.props) : z();
  }
  getStaticValue(e) {
    return this.latestValues[e];
  }
  setStaticValue(e, n) {
    this.latestValues[e] = n;
  }
  /**
   * Make a target animatable by Popmotion. For instance, if we're
   * trying to animate width from 100px to 100vw we need to measure 100vw
   * in pixels to determine what we really need to animate to. This is also
   * pluggable to support Framer's custom value types like Color,
   * and CSS variables.
   */
  makeTargetAnimatable(e, n = !0) {
    return this.makeTargetAnimatableFromInstance(e, this.props, n);
  }
  /**
   * Update the provided props. Ensure any newly-added motion values are
   * added to our map, old ones removed, and listeners updated.
   */
  update(e, n) {
    (e.transformTemplate || this.props.transformTemplate) && this.scheduleRender(), this.prevProps = this.props, this.props = e, this.prevPresenceContext = this.presenceContext, this.presenceContext = n;
    for (let r = 0; r < bs.length; r++) {
      const s = bs[r];
      this.propEventSubscriptions[s] && (this.propEventSubscriptions[s](), delete this.propEventSubscriptions[s]);
      const o = e["on" + s];
      o && (this.propEventSubscriptions[s] = this.on(s, o));
    }
    this.prevMotionValues = bu(this, this.scrapeMotionValuesFromProps(e, this.prevProps), this.prevMotionValues), this.handleChildMotionValue && this.handleChildMotionValue();
  }
  getProps() {
    return this.props;
  }
  /**
   * Returns the variant definition with a given name.
   */
  getVariant(e) {
    return this.props.variants ? this.props.variants[e] : void 0;
  }
  /**
   * Returns the defined default transition on this component.
   */
  getDefaultTransition() {
    return this.props.transition;
  }
  getTransformPagePoint() {
    return this.props.transformPagePoint;
  }
  getClosestVariantNode() {
    return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0;
  }
  getVariantContext(e = !1) {
    if (e)
      return this.parent ? this.parent.getVariantContext() : void 0;
    if (!this.isControllingVariants) {
      const r = this.parent ? this.parent.getVariantContext() || {} : {};
      return this.props.initial !== void 0 && (r.initial = this.props.initial), r;
    }
    const n = {};
    for (let r = 0; r < Tu; r++) {
      const s = jn[r], o = this.props[s];
      (ue(o) || o === !1) && (n[s] = o);
    }
    return n;
  }
  /**
   * Add a child visual element to our set of children.
   */
  addVariantChild(e) {
    const n = this.getClosestVariantNode();
    if (n)
      return n.variantChildren && n.variantChildren.add(e), () => n.variantChildren.delete(e);
  }
  /**
   * Add a motion value and bind it to this visual element.
   */
  addValue(e, n) {
    n !== this.values.get(e) && (this.removeValue(e), this.bindToMotionValue(e, n)), this.values.set(e, n), this.latestValues[e] = n.get();
  }
  /**
   * Remove a motion value and unbind any active subscriptions.
   */
  removeValue(e) {
    this.values.delete(e);
    const n = this.valueSubscriptions.get(e);
    n && (n(), this.valueSubscriptions.delete(e)), delete this.latestValues[e], this.removeValueFromRenderState(e, this.renderState);
  }
  /**
   * Check whether we have a motion value for this key
   */
  hasValue(e) {
    return this.values.has(e);
  }
  getValue(e, n) {
    if (this.props.values && this.props.values[e])
      return this.props.values[e];
    let r = this.values.get(e);
    return r === void 0 && n !== void 0 && (r = Wt(n, { owner: this }), this.addValue(e, r)), r;
  }
  /**
   * If we're trying to animate to a previously unencountered value,
   * we need to check for it in our state and as a last resort read it
   * directly from the instance (which might have performance implications).
   */
  readValue(e) {
    var n;
    return this.latestValues[e] !== void 0 || !this.current ? this.latestValues[e] : (n = this.getBaseTargetFromProps(this.props, e)) !== null && n !== void 0 ? n : this.readValueFromInstance(this.current, e, this.options);
  }
  /**
   * Set the base target to later animate back to. This is currently
   * only hydrated on creation and when we first read a value.
   */
  setBaseTarget(e, n) {
    this.baseTarget[e] = n;
  }
  /**
   * Find the base target for a value thats been removed from all animation
   * props.
   */
  getBaseTarget(e) {
    var n;
    const { initial: r } = this.props, s = typeof r == "string" || typeof r == "object" ? (n = Wn(this.props, r)) === null || n === void 0 ? void 0 : n[e] : void 0;
    if (r && s !== void 0)
      return s;
    const o = this.getBaseTargetFromProps(this.props, e);
    return o !== void 0 && !Z(o) ? o : this.initialValues[e] !== void 0 && s === void 0 ? void 0 : this.baseTarget[e];
  }
  on(e, n) {
    return this.events[e] || (this.events[e] = new Zn()), this.events[e].add(n);
  }
  notify(e, ...n) {
    this.events[e] && this.events[e].notify(...n);
  }
}
class Wi extends wu {
  sortInstanceNodePosition(e, n) {
    return e.compareDocumentPosition(n) & 2 ? 1 : -1;
  }
  getBaseTargetFromProps(e, n) {
    return e.style ? e.style[n] : void 0;
  }
  removeValueFromRenderState(e, { vars: n, style: r }) {
    delete n[e], delete r[e];
  }
  makeTargetAnimatableFromInstance({ transition: e, transitionEnd: n, ...r }, { transformValues: s }, o) {
    let i = Ul(r, e || {}, this);
    if (s && (n && (n = s(n)), r && (r = s(r)), i && (i = s(i))), o) {
      _l(this, r, i);
      const a = vu(this, r, i, n);
      n = a.transitionEnd, r = a.target;
    }
    return {
      transition: e,
      transitionEnd: n,
      ...r
    };
  }
}
function Cu(t) {
  return window.getComputedStyle(t);
}
class Su extends Wi {
  readValueFromInstance(e, n) {
    if (Mt.has(n)) {
      const r = Hn(n);
      return r && r.default || 0;
    } else {
      const r = Cu(e), s = (Ms(n) ? r.getPropertyValue(n) : r[n]) || 0;
      return typeof s == "string" ? s.trim() : s;
    }
  }
  measureInstanceViewportBox(e, { transformPagePoint: n }) {
    return Mi(e, n);
  }
  build(e, n, r, s) {
    Bn(e, n, r, s.transformTemplate);
  }
  scrapeMotionValuesFromProps(e, n) {
    return $n(e, n);
  }
  handleChildMotionValue() {
    this.childSubscription && (this.childSubscription(), delete this.childSubscription);
    const { children: e } = this.props;
    Z(e) && (this.childSubscription = e.on("change", (n) => {
      this.current && (this.current.textContent = `${n}`);
    }));
  }
  renderInstance(e, n, r, s) {
    Bs(e, n, r, s);
  }
}
class Vu extends Wi {
  constructor() {
    super(...arguments), this.isSVGTag = !1;
  }
  getBaseTargetFromProps(e, n) {
    return e[n];
  }
  readValueFromInstance(e, n) {
    if (Mt.has(n)) {
      const r = Hn(n);
      return r && r.default || 0;
    }
    return n = Is.has(n) ? n : Un(n), e.getAttribute(n);
  }
  measureInstanceViewportBox() {
    return z();
  }
  scrapeMotionValuesFromProps(e, n) {
    return Ns(e, n);
  }
  build(e, n, r, s) {
    _n(e, n, r, this.isSVGTag, s.transformTemplate);
  }
  renderInstance(e, n, r, s) {
    _s(e, n, r, s);
  }
  mount(e) {
    this.isSVGTag = Nn(e.tagName), super.mount(e);
  }
}
const Au = (t, e) => Fn(t) ? new Vu(e, { enableHardwareAcceleration: !1 }) : new Su(e, { enableHardwareAcceleration: !0 }), Ru = {
  layout: {
    ProjectionNode: _i,
    MeasureLayout: ki
  }
}, Eu = {
  ...ec,
  ...Ta,
  ...iu,
  ...Ru
}, Ps = /* @__PURE__ */ Mo((t, e) => oa(t, e, Eu, Au));
function zi() {
  const t = ht(!1);
  return je(() => (t.current = !0, () => {
    t.current = !1;
  }), []), t;
}
function Du() {
  const t = zi(), [e, n] = ce(0), r = yn(() => {
    t.current && n(e + 1);
  }, [e]);
  return [yn(() => I.postRender(r), [r]), e];
}
class Mu extends q.Component {
  getSnapshotBeforeUpdate(e) {
    const n = this.props.childRef.current;
    if (n && e.isPresent && !this.props.isPresent) {
      const r = this.props.sizeRef.current;
      r.height = n.offsetHeight || 0, r.width = n.offsetWidth || 0, r.top = n.offsetTop, r.left = n.offsetLeft;
    }
    return null;
  }
  /**
   * Required with getSnapshotBeforeUpdate to stop React complaining.
   */
  componentDidUpdate() {
  }
  render() {
    return this.props.children;
  }
}
function ku({ children: t, isPresent: e }) {
  const n = kn(), r = ht(null), s = ht({
    width: 0,
    height: 0,
    top: 0,
    left: 0
  });
  return Cs(() => {
    const { width: o, height: i, top: a, left: l } = s.current;
    if (e || !r.current || !o || !i)
      return;
    r.current.dataset.motionPopId = n;
    const c = document.createElement("style");
    return document.head.appendChild(c), c.sheet && c.sheet.insertRule(`
          [data-motion-pop-id="${n}"] {
            position: absolute !important;
            width: ${o}px !important;
            height: ${i}px !important;
            top: ${a}px !important;
            left: ${l}px !important;
          }
        `), () => {
      document.head.removeChild(c);
    };
  }, [e]), q.createElement(Mu, { isPresent: e, childRef: r, sizeRef: s }, q.cloneElement(t, { ref: r }));
}
const gn = ({ children: t, initial: e, isPresent: n, onExitComplete: r, custom: s, presenceAffectsLayout: o, mode: i }) => {
  const a = Us(Lu), l = kn(), c = $t(
    () => ({
      id: l,
      initial: e,
      isPresent: n,
      custom: s,
      onExitComplete: (u) => {
        a.set(u, !0);
        for (const f of a.values())
          if (!f)
            return;
        r && r();
      },
      register: (u) => (a.set(u, !1), () => a.delete(u))
    }),
    /**
     * If the presence of a child affects the layout of the components around it,
     * we want to make a new context value to ensure they get re-rendered
     * so they can detect that layout change.
     */
    o ? void 0 : [n]
  );
  return $t(() => {
    a.forEach((u, f) => a.set(f, !1));
  }, [n]), q.useEffect(() => {
    !n && !a.size && r && r();
  }, [n]), i === "popLayout" && (t = q.createElement(ku, { isPresent: n }, t)), q.createElement(Ge.Provider, { value: c }, t);
};
function Lu() {
  return /* @__PURE__ */ new Map();
}
function ju(t) {
  return le(() => () => t(), []);
}
const Bt = (t) => t.key || "";
function Ou(t, e) {
  t.forEach((n) => {
    const r = Bt(n);
    e.set(r, n);
  });
}
function Fu(t) {
  const e = [];
  return vo.forEach(t, (n) => {
    xo(n) && e.push(n);
  }), e;
}
const Bu = ({ children: t, custom: e, initial: n = !0, onExitComplete: r, exitBeforeEnter: s, presenceAffectsLayout: o = !0, mode: i = "sync" }) => {
  it(!s, "Replace exitBeforeEnter with mode='wait'");
  const a = X(On).forceRender || Du()[0], l = zi(), c = Fu(t);
  let u = c;
  const f = ht(/* @__PURE__ */ new Map()).current, h = ht(u), p = ht(/* @__PURE__ */ new Map()).current, m = ht(!0);
  if (je(() => {
    m.current = !1, Ou(c, p), h.current = u;
  }), ju(() => {
    m.current = !0, p.clear(), f.clear();
  }), m.current)
    return q.createElement(q.Fragment, null, u.map((y) => q.createElement(gn, { key: Bt(y), isPresent: !0, initial: n ? void 0 : !1, presenceAffectsLayout: o, mode: i }, y)));
  u = [...u];
  const v = h.current.map(Bt), T = c.map(Bt), P = v.length;
  for (let y = 0; y < P; y++) {
    const x = v[y];
    T.indexOf(x) === -1 && !f.has(x) && f.set(x, void 0);
  }
  return i === "wait" && f.size && (u = []), f.forEach((y, x) => {
    if (T.indexOf(x) !== -1)
      return;
    const w = p.get(x);
    if (!w)
      return;
    const R = v.indexOf(x);
    let N = y;
    if (!N) {
      const k = () => {
        p.delete(x), f.delete(x);
        const V = h.current.findIndex((L) => L.key === x);
        if (h.current.splice(V, 1), !f.size) {
          if (h.current = c, l.current === !1)
            return;
          a(), r && r();
        }
      };
      N = q.createElement(gn, { key: Bt(w), isPresent: !1, onExitComplete: k, custom: e, presenceAffectsLayout: o, mode: i }, w), f.set(x, N);
    }
    u.splice(R, 0, N);
  }), u = u.map((y) => {
    const x = y.key;
    return f.has(x) ? y : q.createElement(gn, { key: Bt(y), isPresent: !0, presenceAffectsLayout: o, mode: i }, y);
  }), process.env.NODE_ENV !== "production" && i === "wait" && u.length > 1 && console.warn(`You're attempting to animate multiple children within AnimatePresence, but its mode is set to "wait". This will lead to odd visual behaviour.`), q.createElement(q.Fragment, null, f.size ? u : u.map((y) => yo(y)));
}, Qn = ({ visible: t, onExitComplete: e, children: n, dataTestId: r }) => /* @__PURE__ */ A.jsx(Bu, { onExitComplete: e, children: t && /* @__PURE__ */ A.jsx(
  Ps.div,
  {
    "data-testid": r,
    className: "rsd-fixed rsd-left-0 rsd-top-0 rsd-z-[9999] rsd-flex rsd-h-full rsd-w-full rsd-items-start rsd-justify-center rsd-bg-gray-900 rsd-bg-opacity-90",
    initial: { backdropFilter: "blur(0px)", opacity: 0 },
    animate: { backdropFilter: "blur(2px)", opacity: 1 },
    exit: { backdropFilter: "blur(0px)", opacity: 0 },
    children: /* @__PURE__ */ A.jsx(
      Ps.div,
      {
        className: "rsd-flex rsd-max-w-md rsd-flex-col rsd-items-center rsd-gap-4 rsd-break-words rsd-rounded-xl rsd-bg-white rsd-px-6 rsd-py-4 rsd-shadow-xl",
        initial: { y: -100, opacity: 0 },
        animate: { y: 50, opacity: 1 },
        exit: { y: "-100%", opacity: 0 },
        children: n
      }
    )
  }
) });
function Gi(t) {
  var e, n, r = "";
  if (typeof t == "string" || typeof t == "number")
    r += t;
  else if (typeof t == "object")
    if (Array.isArray(t))
      for (e = 0; e < t.length; e++)
        t[e] && (n = Gi(t[e])) && (r && (r += " "), r += n);
    else
      for (e in t)
        t[e] && (r && (r += " "), r += e);
  return r;
}
function Iu() {
  for (var t, e, n = 0, r = ""; n < arguments.length; )
    (t = arguments[n++]) && (e = Gi(t)) && (r && (r += " "), r += e);
  return r;
}
const Ts = (t) => typeof t == "boolean" ? "".concat(t) : t === 0 ? "0" : t, ws = Iu, _u = (t, e) => (n) => {
  var r;
  if ((e == null ? void 0 : e.variants) == null)
    return ws(t, n == null ? void 0 : n.class, n == null ? void 0 : n.className);
  const { variants: s, defaultVariants: o } = e, i = Object.keys(s).map((c) => {
    const u = n == null ? void 0 : n[c], f = o == null ? void 0 : o[c];
    if (u === null)
      return null;
    const h = Ts(u) || Ts(f);
    return s[c][h];
  }), a = n && Object.entries(n).reduce((c, u) => {
    let [f, h] = u;
    return h === void 0 || (c[f] = h), c;
  }, {}), l = e == null || (r = e.compoundVariants) === null || r === void 0 ? void 0 : r.reduce((c, u) => {
    let { class: f, className: h, ...p } = u;
    return Object.entries(p).every((m) => {
      let [v, T] = m;
      return Array.isArray(T) ? T.includes({
        ...o,
        ...a
      }[v]) : {
        ...o,
        ...a
      }[v] === T;
    }) ? [
      ...c,
      f,
      h
    ] : c;
  }, []);
  return ws(t, i, l, n == null ? void 0 : n.class, n == null ? void 0 : n.className);
}, Nu = _u(
  "rsd-border-none rsd-rounded rsd-relative rsd-cursor-pointer rsd-shadow rsd-font-normal rsd-inline-flex rsd-items-center rsd-text-sm rsd-transition-colors rsd-duration-75 disabled:rsd-pointer-events-none rsd-h-8 rsd-px-5",
  {
    variants: {
      intent: {
        primary: "rsd-bg-primary-color rsd-text-white hover:rsd-bg-primary-hover-color active:rsd-bg-primary-color",
        ghost: "rsd-shadow-none rsd-bg-white rsd-text-gray-900"
      }
    }
  }
), he = ({ children: t, intent: e = "primary", onClick: n }) => {
  const r = Nu({ intent: e });
  return /* @__PURE__ */ A.jsx("button", { type: "button", onClick: n, className: r, children: t });
}, Uu = ({ message: t, title: e, onClose: n, closeLabel: r }) => {
  const [s, o] = ce(!0), i = () => {
    o(!1);
  };
  return /* @__PURE__ */ A.jsxs(Qn, { visible: s, onExitComplete: n, dataTestId: "alert-dialog", children: [
    /* @__PURE__ */ A.jsxs("div", { className: "rsd-flex rsd-w-full rsd-flex-col rsd-gap-2", children: [
      /* @__PURE__ */ A.jsx("div", { className: "rsd-text-lg rsd-font-semibold rsd-text-gray-900", children: e }),
      /* @__PURE__ */ A.jsx("div", { className: "rsd-text-sm rsd-text-gray-900", children: t })
    ] }),
    /* @__PURE__ */ A.jsx("div", { className: "rsd-h-px rsd-w-full rsd-bg-gray-200" }),
    /* @__PURE__ */ A.jsx(he, { onClick: i, children: r })
  ] });
};
var re = {}, ee = bo;
if (process.env.NODE_ENV === "production")
  re.createRoot = ee.createRoot, re.hydrateRoot = ee.hydrateRoot;
else {
  var Me = ee.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
  re.createRoot = function(t, e) {
    Me.usingClientEntryPoint = !0;
    try {
      return ee.createRoot(t, e);
    } finally {
      Me.usingClientEntryPoint = !1;
    }
  }, re.hydrateRoot = function(t, e, n) {
    Me.usingClientEntryPoint = !0;
    try {
      return ee.hydrateRoot(t, e, n);
    } finally {
      Me.usingClientEntryPoint = !1;
    }
  };
}
const $u = () => {
  const t = document.getElementById("simple-dialog-container");
  if (!t)
    throw new Error(
      "[React Simple Dialogs] Dialog container not found, see: https://github.com/pedrohenriquepires/react-simple-dialogs/wiki/Dialog-Container"
    );
  return t;
}, tr = () => re.createRoot($u()), er = (t, e) => typeof t == "string" ? {
  ...e,
  message: t
} : {
  ...e,
  ...t
}, Xu = (t) => {
  const n = er(t, {
    closeLabel: "Close",
    title: "Attention"
  }), r = tr();
  return new Promise((s) => {
    const o = () => {
      r.unmount(), s();
    };
    r.render(/* @__PURE__ */ A.jsx(Uu, { onClose: o, ...n }));
  });
}, Wu = ({ message: t, title: e, onClose: n, cancelLabel: r, confirmLabel: s }) => {
  const [o, i] = ce(), a = (l) => {
    i(l);
  };
  return /* @__PURE__ */ A.jsxs(Qn, { visible: o === void 0, onExitComplete: () => n(o), dataTestId: "confirmation-dialog", children: [
    /* @__PURE__ */ A.jsxs("div", { className: "rsd-flex rsd-w-full rsd-flex-col rsd-gap-2", children: [
      /* @__PURE__ */ A.jsx("div", { className: "rsd-text-lg rsd-font-semibold rsd-text-gray-900", children: e }),
      /* @__PURE__ */ A.jsx("div", { className: "rsd-text-sm rsd-text-gray-900", children: t })
    ] }),
    /* @__PURE__ */ A.jsx("div", { className: "rsd-h-px rsd-w-full rsd-bg-gray-200" }),
    /* @__PURE__ */ A.jsxs("div", { className: "rsd-flex rsd-gap-2", children: [
      /* @__PURE__ */ A.jsx(he, { onClick: () => a(!0), children: s }),
      /* @__PURE__ */ A.jsx(he, { onClick: () => a(!1), intent: "ghost", children: r })
    ] })
  ] });
}, Zu = (t) => {
  const n = er(t, {
    cancelLabel: "Cancel",
    confirmLabel: "Confirm",
    title: "Attention"
  }), r = tr();
  return new Promise((s) => {
    const o = (i) => {
      r.unmount(), s(i);
    };
    r.render(/* @__PURE__ */ A.jsx(Wu, { onClose: o, ...n }));
  });
}, zu = ({ label: t, name: e, onChange: n, dataTestId: r }) => /* @__PURE__ */ A.jsxs("div", { className: "rsd-w-full", children: [
  /* @__PURE__ */ A.jsx("label", { htmlFor: e, className: "rsd-block rsd-text-xs rsd-font-medium rsd-text-gray-700", children: t }),
  /* @__PURE__ */ A.jsx(
    "input",
    {
      onChange: n,
      id: e,
      name: e,
      "data-testid": r,
      className: "rsd-mt-1 rsd-w-full rsd-rounded-md rsd-border rsd-border-solid rsd-border-gray-200 rsd-bg-white rsd-px-3 rsd-py-2 rsd-text-black rsd-outline-none"
    }
  )
] }), Gu = ({ message: t, title: e, onClose: n, cancelLabel: r, confirmLabel: s, inputLabel: o }) => {
  const [i, a] = ce(!0), [l, c] = ce(""), u = () => {
    a(!1);
  }, f = () => {
    c(null), a(!1);
  }, h = (p) => {
    const { currentTarget: m } = p;
    c(m.value);
  };
  return /* @__PURE__ */ A.jsxs(Qn, { visible: i, onExitComplete: () => n(l), dataTestId: "prompt-dialog", children: [
    /* @__PURE__ */ A.jsxs("div", { className: "rsd-flex rsd-w-full rsd-flex-col rsd-gap-2", children: [
      /* @__PURE__ */ A.jsx("div", { className: "rsd-text-lg rsd-font-semibold rsd-text-gray-900", children: e }),
      /* @__PURE__ */ A.jsx("div", { className: "rsd-text-sm rsd-text-gray-900", children: t })
    ] }),
    /* @__PURE__ */ A.jsx("div", { className: "rsd-w-full", children: /* @__PURE__ */ A.jsx(zu, { onChange: h, label: o, name: "value", dataTestId: "prompt-input" }) }),
    /* @__PURE__ */ A.jsx("div", { className: "rsd-h-px rsd-w-full rsd-bg-gray-200" }),
    /* @__PURE__ */ A.jsxs("div", { className: "rsd-flex rsd-gap-2", children: [
      /* @__PURE__ */ A.jsx(he, { onClick: () => u(), children: s }),
      /* @__PURE__ */ A.jsx(he, { onClick: () => f(), intent: "ghost", children: r })
    ] })
  ] });
}, Ju = (t) => {
  const n = er(t, {
    cancelLabel: "Cancel",
    confirmLabel: "Confirm",
    inputLabel: "Value",
    title: "Attention"
  }), r = tr();
  return new Promise((s) => {
    const o = (i) => {
      r.unmount(), s(i);
    };
    r.render(/* @__PURE__ */ A.jsx(Gu, { onClose: o, ...n }));
  });
}, Yu = `.rsd-fixed{position:fixed!important}.rsd-relative{position:relative!important}.rsd-left-0{left:0!important}.rsd-top-0{top:0!important}.rsd-z-\\[9999\\]{z-index:9999!important}.rsd-mt-1{margin-top:.25rem!important}.rsd-block{display:block!important}.rsd-flex{display:flex!important}.rsd-inline-flex{display:inline-flex!important}.rsd-h-8{height:2rem!important}.rsd-h-full{height:100%!important}.rsd-h-px{height:1px!important}.rsd-w-full{width:100%!important}.rsd-max-w-md{max-width:28rem!important}.rsd-cursor-pointer{cursor:pointer!important}.rsd-flex-col{flex-direction:column!important}.rsd-items-start{align-items:flex-start!important}.rsd-items-center{align-items:center!important}.rsd-justify-center{justify-content:center!important}.rsd-gap-2{gap:.5rem!important}.rsd-gap-4{gap:1rem!important}.rsd-break-words{overflow-wrap:break-word!important}.rsd-rounded{border-radius:.25rem!important}.rsd-rounded-md{border-radius:.375rem!important}.rsd-rounded-xl{border-radius:.75rem!important}.rsd-border{border-width:1px!important}.rsd-border-solid{border-style:solid!important}.rsd-border-none{border-style:none!important}.rsd-border-gray-200{--tw-border-opacity: 1 !important;border-color:rgb(229 231 235 / var(--tw-border-opacity))!important}.rsd-bg-gray-200{--tw-bg-opacity: 1 !important;background-color:rgb(229 231 235 / var(--tw-bg-opacity))!important}.rsd-bg-gray-900{--tw-bg-opacity: 1 !important;background-color:rgb(17 24 39 / var(--tw-bg-opacity))!important}.rsd-bg-primary-color{background-color:var(--rsd-primary-color)!important}.rsd-bg-white{--tw-bg-opacity: 1 !important;background-color:rgb(255 255 255 / var(--tw-bg-opacity))!important}.rsd-bg-opacity-90{--tw-bg-opacity: .9 !important}.rsd-px-3{padding-left:.75rem!important;padding-right:.75rem!important}.rsd-px-5{padding-left:1.25rem!important;padding-right:1.25rem!important}.rsd-px-6{padding-left:1.5rem!important;padding-right:1.5rem!important}.rsd-py-2{padding-top:.5rem!important;padding-bottom:.5rem!important}.rsd-py-4{padding-top:1rem!important;padding-bottom:1rem!important}.rsd-text-lg{font-size:1.125rem!important;line-height:1.75rem!important}.rsd-text-sm{font-size:.875rem!important;line-height:1.25rem!important}.rsd-text-xs{font-size:.75rem!important;line-height:1rem!important}.rsd-font-medium{font-weight:500!important}.rsd-font-normal{font-weight:400!important}.rsd-font-semibold{font-weight:600!important}.rsd-text-black{--tw-text-opacity: 1 !important;color:rgb(0 0 0 / var(--tw-text-opacity))!important}.rsd-text-gray-700{--tw-text-opacity: 1 !important;color:rgb(55 65 81 / var(--tw-text-opacity))!important}.rsd-text-gray-900{--tw-text-opacity: 1 !important;color:rgb(17 24 39 / var(--tw-text-opacity))!important}.rsd-text-white{--tw-text-opacity: 1 !important;color:rgb(255 255 255 / var(--tw-text-opacity))!important}.rsd-shadow{--tw-shadow: 0 1px 3px 0 rgb(0 0 0 / .1), 0 1px 2px -1px rgb(0 0 0 / .1) !important;--tw-shadow-colored: 0 1px 3px 0 var(--tw-shadow-color), 0 1px 2px -1px var(--tw-shadow-color) !important;box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)!important}.rsd-shadow-none{--tw-shadow: 0 0 #0000 !important;--tw-shadow-colored: 0 0 #0000 !important;box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)!important}.rsd-shadow-xl{--tw-shadow: 0 20px 25px -5px rgb(0 0 0 / .1), 0 8px 10px -6px rgb(0 0 0 / .1) !important;--tw-shadow-colored: 0 20px 25px -5px var(--tw-shadow-color), 0 8px 10px -6px var(--tw-shadow-color) !important;box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)!important}.rsd-outline-none{outline:2px solid transparent!important;outline-offset:2px!important}.rsd-transition-colors{transition-property:color,background-color,border-color,text-decoration-color,fill,stroke!important;transition-timing-function:cubic-bezier(.4,0,.2,1)!important;transition-duration:.15s!important}.rsd-duration-75{transition-duration:75ms!important}.hover\\:rsd-bg-primary-hover-color:hover{background-color:var(--rsd-primary-hover-color)!important}.active\\:rsd-bg-primary-color:active{background-color:var(--rsd-primary-color)!important}.disabled\\:rsd-pointer-events-none:disabled{pointer-events:none!important}
`, Qu = ({
  primaryColor: t = "rgb(3 105 161)",
  primaryHoverColor: e = "rgb(2 132 199)"
}) => /* @__PURE__ */ A.jsxs("div", { className: "simple-dialog", children: [
  /* @__PURE__ */ A.jsxs("style", { "data-testid": "simple-dialog-styles", children: [
    `:root { --rsd-primary-color: ${t}; --rsd-primary-hover-color: ${e} }`,
    Yu
  ] }),
  /* @__PURE__ */ A.jsx("div", { id: "simple-dialog-container", "data-testid": "simple-dialog-container" })
] });
export {
  Qu as SimpleDialogContainer,
  Xu as simpleAlert,
  Zu as simpleConfirm,
  Ju as simplePrompt
};
